<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Soul Collector - Abyssal Ascension</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&family=Sorts+Mill+Goudy&display=swap');
        :root {
            --background-color: #0a0908; --dark-panel-color: #1c1a19; --light-panel-color: #2a2726;
            --border-color: #4d4d4d; --primary-color: #b32121; --primary-glow: rgba(179, 33, 33, 0.7);
            --accent-color: #d4af37; --accent-glow: rgba(212, 175, 55, 0.5);
            --prestige-color: #e8e8e8; --prestige-glow: rgba(232, 232, 232, 0.5);
            --secondary-color: #d1cbc1; --dim-color: #8a8174;
            --font-title: 'Cinzel Decorative', serif; --font-body: 'Sorts Mill Goudy', serif;
            --font-size-base: 16px; --font-size-large: 1.2rem; --font-size-xl: 1.8rem; --font-size-xxl: 2.5rem;
            --border-radius: 2px; --transition-speed: 0.3s;
        }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.98); } to { opacity: 1; transform: scale(1); } }
        @keyframes soulThump { 0% { transform: scale(1); } 50% { transform: scale(0.97); } 100% { transform: scale(1); } }
        .soul-particle { position: absolute; width: 5px; height: 15px; background: var(--primary-color); border: 1px solid black; box-shadow: 0 0 10px var(--primary-glow); pointer-events: none; opacity: 1; animation: fly-out 0.8s ease-out forwards; }
        @keyframes fly-out { from { transform: translate(0, 0) scale(1) rotate(0deg); opacity: 1; } to { transform: translate(var(--x), var(--y)) scale(0) rotate(360deg); opacity: 0; } }
        body { background-color: var(--background-color); box-shadow: inset 0 0 150px #000; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEWFhYWDg4N3d3dtbW17e3t1dXWBgYGHh4d5eXlzc3OLi4ubm5uVlZWPj4+NjY19fX2JiYqUlJSbm5rR0dGSkpJZWVl4eHhfX1/Kysqztba6urqloqPy8/P19fX7+/sbwLSUAAAANElEQVR42mNgBAINDDxdgIvNlBPEyYPAyMDM0M0w9D8cmBjg8D8yMDBdBSMDBgABo4MBgABhIUgAAAAASUVORK5CYII='); color: var(--secondary-color); font-family: var(--font-body); font-size: var(--font-size-base); text-align: center; padding: 15px; margin: 0; user-select: none; }
        #game-container { max-width: 950px; margin: 20px auto; border: 3px solid #111; border-top: 3px solid #333; border-bottom: 3px solid #333; background-color: var(--dark-panel-color); background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyBAMAAADsEZWCAAAAFVBMVEUuLi4nJycnJycrKysrKyspKSkpKSkQCBURAAAAB3RSTlMAoAr2p/Th2c9jAAAAh0lEQVQ4y2NgGAWjgEVBIIsFWBIMdkyY2DBRYGPB+MvAxIaJCTMdxgATRIYN+2A0wEjEASZ0mHw3g8jEASZ0GHo3g8jEASZ0mHw3g8jEASZ0GHo3g8jEASZ0mHw3g8jEASZ0GHo3g8jEASZ0mHw3g8jEASZ0GAYBAB2wAkeI31rqAAAAAElFTSuQmCC'); box-shadow: 0 0 50px rgba(0,0,0,0.9); overflow: hidden; }
        nav { display: flex; background-color: #000; border-bottom: 3px solid #111; flex-wrap: wrap; }
        nav button { flex-grow: 1; padding: 18px 5px; font-family: var(--font-title); background: var(--dark-panel-color); border: none; border-right: 1px solid #000; color: var(--dim-color); font-size: var(--font-size-large); cursor: pointer; transition: all var(--transition-speed); }
        nav button:last-child { border-right: none; }
        nav button:hover { background-color: var(--light-panel-color); color: var(--accent-color); }
        nav button.active { background: linear-gradient(to top, var(--primary-color), #c83131); color: white; text-shadow: 0 0 8px black; font-size: 1.25rem; }
        .screen { padding: 25px; display: none; }
        .screen.active { display: block; animation: fadeIn 0.7s; }
        #player-stats { display: flex; justify-content: space-around; flex-wrap: wrap; background: #050505; padding: 15px; border-bottom: 3px solid #111; font-family: var(--font-title); font-size: var(--font-size-large); }
        #player-stats div { margin: 5px 15px; } #player-stats span { font-weight: bold; }
        #souls-display, #essence-display, #shards-display { text-shadow: 0 0 10px currentColor; }
        #essence-display { color: var(--accent-color); } #shards-display { color: var(--prestige-color); }
        h1, h2, h3 { font-family: var(--font-title); color: var(--primary-color); text-shadow: 1px 1px 0 #000, 3px 3px 5px #000, 0 0 15px var(--primary-glow); text-transform: uppercase; letter-spacing: 3px; }
        h1 { font-size: var(--font-size-xxl); } h2 { font-size: var(--font-size-xl); margin-bottom: 0; }
        h3 { color: var(--secondary-color); text-shadow: 1px 1px 2px #000; letter-spacing: 1px; }
        .screen p { font-size: 1.1rem; }
        #rift-container {
            position: relative;
            margin: 25px auto;
            /* Set a fixed size so the layout doesn't jump */
            width: 300px; 
            height: 120px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #rift-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1; /* Behind the button */
            pointer-events: none; /* Allows clicks to pass through to the button */
            opacity: 0.7;
        }
        button.action-btn {
            position: relative; /* Make sure button is on top */
            z-index: 2;
        }
        #rift-container { position: relative; margin: 25px auto; width: 300px; height: 120px; }
        #rift-canvas { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1; pointer-events: none; opacity: 0.7; }
        button.action-btn { padding: 25px 50px; font-size: var(--font-size-xl); font-family: var(--font-title); background: linear-gradient(145deg, #c02323, var(--primary-color)); color: white; border: 2px solid #000; border-bottom: 4px solid #000; border-right: 4px solid #000; box-shadow: inset 0 0 15px rgba(0,0,0,0.7); cursor: pointer; transition: all 0.1s ease-out; text-transform: uppercase; display: block; position: relative; z-index: 2; margin: 0 auto; }
        button.action-btn:hover { background: #d03333; }
        button.action-btn:active { transform: translate(2px, 2px); border-bottom-width: 2px; border-right-width: 2px; }
        .action-btn.thump-animation { animation: soulThump 0.2s ease-in-out; }
        .upgrade-section, .minion-grid, .artifact-grid { display: flex; justify-content: center; gap: 20px; margin-top: 30px; flex-wrap: wrap; }
        button.upgrade-btn { padding: 20px; background: var(--light-panel-color); color: var(--secondary-color); cursor: pointer; border: 2px solid var(--border-color); width: 260px; text-align: left; border-radius: var(--border-radius); transition: all var(--transition-speed); box-shadow: inset 0 0 10px rgba(0,0,0,0.5); line-height: 1.5; }
        button.upgrade-btn:hover:not(:disabled) { border-color: var(--accent-color); background: #33302e; transform: translateY(-2px); box-shadow: inset 0 0 5px rgba(0,0,0,0.5), 0 2px 10px var(--accent-glow); }
        button.upgrade-btn.owned, button:disabled { background-color: var(--dark-panel-color); color: #666; cursor: not-allowed; border-color: #333; filter: grayscale(80%); }
        .btn-title { font-family: var(--font-title); font-size: 1.4rem; color: white; letter-spacing: 1px; margin-bottom: 5px; }
        .btn-level { color: var(--dim-color); font-size: 1rem; font-style: italic; }
        .cost { font-size: 1.1rem; margin-top: 10px; display: block; }
        .cost-souls { color: var(--prestige-color); font-weight: bold; } .cost-essence { color: var(--accent-color); font-weight: bold; } .cost-shards { color: var(--prestige-color); font-weight: bold; }
        hr { border: 0; height: 2px; background: #000; margin: 30px 0; }
        #map-grid, #leaderboard-list, #pvp-target-list, #pvp-log-list { list-style: none; padding: 0; text-align: left; margin: 20px auto; max-width: 650px; }
        #map-grid li, #leaderboard-list li, #pvp-target-list li, #pvp-log-list li { background: var(--light-panel-color); border: 2px solid var(--border-color); padding: 20px; margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center; border-radius: var(--border-radius); font-size: 1.1rem; }
        #map-grid li.active-world { border-color: var(--primary-color); background: var(--dark-panel-color); }
        #leaderboard-list li:first-child { border-color: gold; box-shadow: 0 0 15px rgba(255,215,0,0.5); }
        #ascension-screen { border: 3px double var(--primary-color); background-color: rgba(160, 28, 28, 0.1); padding: 30px; }
        #ascension-screen h2 { color: var(--primary-color); } .ascend-btn { background: var(--prestige-color); color: #000; font-family: var(--font-title); font-weight: bold; font-size: 1.3rem; border: 2px solid #000; }
        #profile-setup { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; justify-content: center; align-items: center; z-index: 100; backdrop-filter: blur(5px); }
        #profile-setup div { padding: 40px; background: var(--dark-panel-color); border: 2px solid #000; box-shadow: 0 0 40px rgba(0,0,0,0.7); }
        #profile-setup input { padding: 10px; font-size: 1.1rem; background: #111; border: 1px solid #333; color: white; margin-right: 10px; border-radius: 0; font-family: var(--font-body); }
        #profile-setup input:focus { border-color: var(--primary-color); outline: none; }
        [data-tooltip] { position: relative; }
        [data-tooltip]::after { content: attr(data-tooltip); position: absolute; left: 50%; bottom: 110%; transform: translateX(-50%); background: #000; border: 1px solid var(--border-color); color: var(--secondary-color); padding: 10px 15px; border-radius: var(--border-radius); font-size: 1rem; font-family: var(--font-body); pointer-events: none; opacity: 0; transition: opacity var(--transition-speed); width: max-content; max-width: 320px; z-index: 10; line-height: 1.4; }
        [data-tooltip]:hover::after { opacity: 1; }
        #duel-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; justify-content: center; align-items: center; z-index: 200; backdrop-filter: blur(5px); }
        #duel-container { width: 90%; max-width: 600px; text-align: center; color: white; }
        #duel-title { font-size: 3rem; color: var(--primary-color); text-shadow: 0 0 15px var(--primary-glow); }
        .duel-bar-container { margin: 15px 0; font-family: var(--font-title); font-size: 1.2rem; }
        .health-bar { width: 100%; height: 30px; background-color: #333; border: 2px solid #111; margin-top: 5px; padding: 2px; }
        .health-fill { height: 100%; width: 100%; background: linear-gradient(to right, var(--primary-color), #d03333); transition: width 0.2s linear; }
        #player-health-fill { background: linear-gradient(to right, #00e5ff, #00a1b8); }
        #duel-arena { position: relative; width: 250px; height: 250px; margin: 40px auto; border: 2px solid var(--border-color); border-radius: 50%; background: radial-gradient(circle, #222, #000); }
        #soul-core { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100px; height: 100px; background-color: var(--primary-color); border-radius: 50%; cursor: pointer; box-shadow: 0 0 20px var(--primary-glow), inset 0 0 15px rgba(0,0,0,0.7); transition: transform 0.1s; }
        #soul-core:active { transform: translate(-50%, -50%) scale(0.9); }
        .weak-point { position: absolute; width: 40px; height: 40px; background-color: var(--accent-color); border-radius: 50%; cursor: pointer; box-shadow: 0 0 15px var(--accent-glow); animation: fadeIn 0.5s; z-index: 210; }
        .weak-point:hover { transform: scale(1.1); }
        #duel-timer { font-size: 2.5rem; font-family: var(--font-title); color: var(--prestige-color); }
        #cache-container { padding: 15px; background: #050505; border-top: 3px solid #111; }
        #abyssal-cache-btn { width: 300px; padding: 10px; font-family: var(--font-title); font-size: 1.5rem; color: white; background: linear-gradient(145deg, #444, #222); border: 2px solid #000; cursor: pointer; transition: all 0.2s; }
        #abyssal-cache-btn:not(:disabled) { background: linear-gradient(145deg, var(--accent-color), #b8860b); text-shadow: 0 0 10px white; animation: pulseCache 2s infinite; }
        @keyframes pulseCache { 0% { transform: scale(1); box-shadow: 0 0 10px transparent; } 50% { transform: scale(1.03); box-shadow: 0 0 20px var(--accent-glow); } 100% { transform: scale(1); box-shadow: 0 0 10px transparent; } }
        #cache-timer-text { font-size: 1rem; font-family: var(--font-body); color: var(--dim-color); }
        #abyssal-cache-btn:not(:disabled) #cache-timer-text { color: white; font-weight: bold; }
        #item-modal-overlay, #lore-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; justify-content: center; align-items: center; z-index: 300; backdrop-filter: blur(5px); }
        #item-modal-content, #lore-modal-content { padding: 30px; background: var(--dark-panel-color); border: 2px solid var(--accent-color); text-align: center; box-shadow: 0 0 30px var(--accent-glow); max-width: 400px; }
        #item-modal-reward { margin: 20px 0; padding: 20px; background: var(--light-panel-color); border: 1px solid var(--border-color); }
        .item-name { font-family: var(--font-title); font-size: 1.5rem; }
        .item-desc { font-family: var(--font-body); font-size: 1rem; color: var(--secondary-color); max-width: 300px; }
    </style>
</head>
<body>
    <div id="duel-overlay" style="display: none;">
        <div id="duel-container">
            <h2 id="duel-title">Channeling Duel!</h2>
            <div class="duel-bar-container">
                <div id="opponent-name">VS SkullMancer</div>
                <div class="health-bar"><div id="opponent-health-fill" class="health-fill"></div></div>
            </div>
            <div id="duel-arena">
                <div id="soul-core" onclick="duelClickCore()"></div>
            </div>
            <div class="duel-bar-container">
                <div id="player-duel-name">Your Power</div>
                <div class="health-bar"><div id="player-health-fill" class="health-fill"></div></div>
            </div>
            <div id="duel-timer">15</div>
        </div>
    </div>
    <div id="profile-setup" style="display: none;">
        <div>
            <h2>Create Your Profile</h2>
            <p>Enter your name, Soul Collector.</p>
            <input type="text" id="playerNameInput" placeholder="BoneLordX" maxlength="15">
            <button class="upgrade-btn" onclick="createProfile()">Begin the Harvest</button>
        </div>
    </div>
    <div id="game-container" style="display: none;">
        <header id="player-stats">
            <div>Player: <span id="playerName-display"></span></div>
            <div>Souls: <span id="souls-display">0</span></div>
            <div><span style="color:var(--accent-color)">Dark Essence:</span> <span id="essence-display">0</span></div>
            <div><span style="color:var(--prestige-color)">Abyssal Shards:</span> <span id="shards-display">0</span></div>
        </header>
        <nav>
            <button onclick="showScreen('altar')" class="active">Altar</button>
            <button onclick="showScreen('minions')">Minions</button>
            <button onclick="showScreen('brewery')">Brewery</button>
            <button onclick="showScreen('inventory')">Inventory</button>
            <button onclick="showScreen('artifacts')">Artifacts</button>
            <button onclick="showScreen('rituals')">Rituals</button>
            <button onclick="showScreen('map')">Worlds</button>
            <button onclick="showScreen('pvp')">Raids</button>
            <button onclick="showScreen('leaderboard')">Leaderboard</button>
            <button onclick="showScreen('ascension')">ASCEND</button>
            <button onclick="showScreen('settings')">Settings</button>
        </nav>
        <main>
            <div id="altar-screen" class="screen active">
                <h1 id="world-title">👻 Nether Plains 👻</h1>
                <p>Souls Per Second: <span id="sps-display">0</span> | Souls Per Click: <span id="spc-display">1</span></p>
                <div id="rift-container">
                    <canvas id="rift-canvas" width="400" height="200"></canvas>
                    <button class="action-btn" onclick="harvestSoul()">Harvest Soul</button>
                </div>
                <div class="upgrade-section">
                    <button class="upgrade-btn" id="clickUpgradeBtn" onclick="buyUpgrade('click')">
                        <span class="btn-title">Empower Harvest</span><br>
                        <span class="btn-level">Lvl: <span id="clickLevel">1</span></span><br>
                        <span class="cost">Cost: <span id="clickCost" class="cost-souls">10</span></span>
                    </button>
                    <button class="upgrade-btn" id="sacrificeBtn" onclick="buyUpgrade('sacrifice')">
                        <span class="btn-title">Sacrifice Souls</span><br>
                        <span>Gain 1 Dark Essence</span><br>
                        <span class="cost">Cost: <span id="sacrificeCost" class="cost-souls">1000</span></span>
                    </button>                    
                    <button class="upgrade-btn" id="resonanceUpgradeBtn" onclick="buyUpgrade('resonance')" data-tooltip="This is a permanent upgrade that persists through Ascension. It's one of the most important upgrades for long-term growth!">
                        <span class="btn-title">Soul Resonance</span><br>
                        <span class="btn-level">Lvl: <span id="resonanceLevel">0</span></span><br>
                        <span class="cost">Gain +5% Shards on Ascend per level.</span><br>
                        <span class="cost">Cost: <span id="resonanceCost" class="cost-essence">5</span></span>
                    </button>
                </div>
            </div>
            <div id="brewery-screen" class="screen">
                <h2>The Alchemical Brewery</h2><p>Concoct powerful, single-use potions for potent effects.</p>
                <h3>Your Inventory</h3><div id="potion-inventory" class="minion-grid"></div><hr>
                <h3>Available Recipes</h3><div id="potion-recipe-grid" class="minion-grid"></div>
            </div>
            <div id="inventory-screen" class="screen">
                <h2>Inventory & Equipment</h2><p>Equip items from your Abyssal Caches to gain their powerful bonuses.</p>
                <h3>Equipped Items</h3><div id="equipped-items-grid" class="minion-grid"></div><hr>
                <h3>Stored Items</h3><div id="inventory-items-grid" class="minion-grid"></div>
            </div>
            <div id="minions-screen" class="screen">
                <h2>😈 Demonic Minions 😈</h2><p>Enslave creatures to passively harvest souls for you.</p>
                <div id="minion-grid" class="minion-grid"></div>
            </div>
            <div id="artifacts-screen" class="screen">
                <h2>💎 Abyssal Artifacts 💎</h2><p>Spend Dark Essence on powerful, permanent items.</p>
                <div id="artifact-grid" class="artifact-grid"></div>
            </div>
            <div id="rituals-screen" class="screen">
                <h2>🔮 Dark Rituals 🔮</h2><p>Perform costly rituals for immense, temporary power.</p>
                <div id="ritual-grid" class="ritual-grid"></div>
            </div>
            <div id="map-screen" class="screen">
                <h2>🌐 Map of the Underworlds</h2><ul id="map-grid"></ul>
            </div>
            <div id="pvp-screen" class="screen">
                <h2>🔥 PvP Soul Raids 🔥</h2><p>Raid the databases of other players for souls and glory.</p>
                <div id="pvp-actions"><button class="upgrade-btn" onclick="fetchPvpTargets()">Find New Opponents</button>
                <div id="raid-cooldown-timer"></div></div>
                <h3>Potential Targets</h3><ul id="pvp-target-list" class="leaderboard-list"></ul><hr>
                <h3>Your Raid Log</h3><ul id="pvp-log-list" class="leaderboard-list"></ul>
            </div>
            <div id="leaderboard-screen" class="screen">
                <h2>🏆 Leaderboards 🏆</h2>
                <div class="upgrade-section">
                    <button class="upgrade-btn" onclick="fetchLeaderboard('lifetimeSouls')">By Total Souls</button>
                    <button class="upgrade-btn" onclick="fetchLeaderboard('ascensions')">By Ascensions</button>
                    <button class="upgrade-btn" onclick="fetchLeaderboard('pvpWins')">By PvP Wins</button>
                </div>
                <h3 id="leaderboard-title">Ranking by Total Souls</h3><ul id="leaderboard-list"></ul>
            </div>
            <div id="ascension-screen" class="screen">
                <h2>✨ Shatter the Soul Core ✨</h2>
                <p>Ascension is the key to true power. Reset your current progress (souls, minions, upgrades, worlds) to gain <span class="cost-shards">Abyssal Shards</span> based on your total souls harvested this run.</p>
                <p>Shards provide a MASSIVE permanent boost to all soul gains.</p>
                <p>Requirement: Reach the 'Void Threshold' world to unlock.</p><hr>
                <h3>You will gain: <span id="shardsOnAscend" class="cost-shards">0</span> Abyssal Shards</h3>
                <button class="upgrade-btn ascend-btn" id="ascendBtn" onclick="performAscension()" disabled>ASCEND</button>
            </div>
                        <!-- Screen 11: Settings -->
            <div id="settings-screen" class="screen">
                <h2>Settings</h2>
                <p>Manage your game experience.</p>
                <div class="upgrade-section">
                    <button class="upgrade-btn" id="musicToggleBtn" onclick="toggleMusic()">
                        <span class="btn-title">Toggle Music</span>
                        <span id="musicStatus">Status: ON</span>
                    </button>
                    <button class="upgrade-btn" id="sfxToggleBtn" onclick="toggleSfx()">
                        <span class="btn-title">Toggle SFX</span>
                        <span id="sfxStatus">Status: ON</span>
                    </button>
                    <button class="upgrade-btn" onclick="hardReset()">
                        <span class="btn-title">Hard Reset</span>
                        <span>Erase all progress and start over.</span>
                    </button>
                </div>
            </div>
            <div id="cache-container">
                <button id="abyssal-cache-btn" onclick="openAbyssalCache()" disabled>
                    <div id="cache-ready-text">ABYSSAL CACHE</div><div id="cache-timer-text">Sealed...</div>
                </button>
            </div>
            <div id="item-modal-overlay" style="display: none;">
                <div id="item-modal-content">
                    <h2 id="item-modal-title">Cache Opened!</h2>
                    <div id="item-modal-reward"></div>
                    <button class="upgrade-btn" onclick="closeItemModal()">Claim</button>
                </div>
            </div>
            <div id="lore-modal-overlay" style="display: none;">
                 <div id="lore-modal-content">
                    <h2 id="lore-modal-title"></h2>
                    <p id="lore-modal-text"></p>
                    <button class="upgrade-btn" onclick="closeLoreModal()">Continue</button>
                </div>
            </div>
        </main>
    </div>

<script>
// =================================================================
// PVP DATABASE & AUDIO SETUP (SUPABASE - FINAL CORRECTED VERSION)
// =================================================================
// --- THIS IS WHERE YOUR SUPABASE KEYS GO ---
const SUPABASE_URL = 'https://gqlpebvyiobwdyiezxma.supabase.co'; 
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdxbHBlYnZ5aW9id2R5aWV6eG1hIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM4ODc5NDksImV4cCI6MjA2OTQ2Mzk0OX0.t2ezVurCrC1uOsdKaPJSddQmdeQnhPlFlv9HDTSftHQ';
// -------------------------------------------------

// Correctly initialize the Supabase client.
const { createClient } = supabase;
const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const audio = {
    bgm: new Audio("https://files.catbox.moe/usk1qh.mp3"),
    click: new Audio("https://files.catbox.moe/pckmbk.mp3"),
    harvest: new Audio("https://files.catbox.moe/gg4snq.mp3"),
    ascend: new Audio("https://files.catbox.moe/q0gkux.mp3"),
    upgrade: new Audio("https://files.catbox.moe/gae6li.mp3"),
    sfxMuted: false // a new property to track sound effects
};
audio.bgm.loop = true;
audio.bgm.volume = 0.8;

// =================================================================
// GAME DATA
// =================================================================
const numberFormatter = new Intl.NumberFormat('en-US', { notation: 'compact', compactDisplay: 'short' });
function formatNumber(num) { if (num < 100000) return Math.floor(num).toLocaleString(); return numberFormatter.format(num); }
const minions = {
  imp: { name: "Imp", baseSps: 0.1, cost: 25, multiplier: 1.15, requiredWorld: 'nether_plains' },
  ghoul: { name: "Ghoul", baseSps: 0.5, cost: 150, multiplier: 1.16, requiredWorld: 'nether_plains' },
  demon: { name: "Lesser Demon", baseSps: 2, cost: 1000, multiplier: 1.18, requiredWorld: 'nether_plains' },
  ash_golem: { name: "Ash Golem", baseSps: 15, cost: 50000, multiplier: 1.20, requiredWorld: 'ashen_wastes' },
  cinder_wraith: { name: "Cinder Wraith", baseSps: 80, cost: 3e5, multiplier: 1.21, requiredWorld: 'ashen_wastes' },
  abyssal_stalker: { name: "Abyssal Stalker", baseSps: 400, cost: 1.5e6, multiplier: 1.22, requiredWorld: 'stygian_depths', bonus: {type: 'sps_to_spc', value: 0.0001}},
  river_hydra: { name: "River Hydra", baseSps: 2200, cost: 8e6, multiplier: 1.23, requiredWorld: 'stygian_depths' },
  hellhound: { name: "Hellhound", baseSps: 1.2e4, cost: 4e7, multiplier: 1.24, requiredWorld: 'burning_hells' },
  balrog: { name: "Balrog", baseSps: 6e4, cost: 2.5e8, multiplier: 1.25, requiredWorld: 'burning_hells' },
  pit_lord: { name: "Pit Lord", baseSps: 3e5, cost: 1.5e9, multiplier: 1.26, requiredWorld: 'burning_hells' },
  frost_lich: { name: "Frost Lich", baseSps: 2e6, cost: 8e9, multiplier: 1.28, requiredWorld: 'frozen_abyss' },
  icefiend: { name: "Icefiend", baseSps: 1.1e7, cost: 5e10, multiplier: 1.29, requiredWorld: 'frozen_abyss' },
  glacial_titan: { name: "Glacial Titan", baseSps: 6e7, cost: 3e11, multiplier: 1.30, requiredWorld: 'frozen_abyss', bonus: {type: 'global_sps_multiplier_per_level', value: 0.001}},
  fallen_angel: { name: "Fallen Angel", baseSps: 4e8, cost: 2e12, multiplier: 1.32, requiredWorld: 'celestial_ruins' },
  corrupted_cherub:{ name: "Corrupted Cherub", baseSps: 2.5e9, cost: 1.2e13, multiplier: 1.33, requiredWorld: 'celestial_ruins' },
  void_spawn: { name: "Void Spawn", baseSps: 1.5e10, cost: 7e13, multiplier: 1.35, requiredWorld: 'void_threshold' },
  shoggoth: { name: "Shoggoth", baseSps: 9e10, cost: 4e14, multiplier: 1.36, requiredWorld: 'void_threshold' },
  reality_warper: { name: "Reality Warper", baseSps: 6e12, cost: 2e16, multiplier: 1.38, requiredWorld: 'singularity' },
  echo_of_nothing: { name: "Echo of Nothing", baseSps: 4e13, cost: 1e17, multiplier: 1.40, requiredWorld: 'singularity', bonus: {type: 'shards_from_ascension_multiplier_per_level', value: 0.002}},
  spacetime_ghast: { name: "Spacetime Ghast", baseSps: 3e15, cost: 5e19, multiplier: 1.42, requiredWorld: 'event_horizon' },
  causal_predator: { name: "Causal Predator", baseSps: 2e16, cost: 3e20, multiplier: 1.44, requiredWorld: 'event_horizon', bonus: {type: 'essence_multiplier_per_level', value: 0.005 }},
  nebulous_entity: { name: "Nebulous Entity", baseSps: 1e18, cost: 2e22, multiplier: 1.46, requiredWorld: 'genesis' },
  creator_wisp: { name: "Creator Wisp", baseSps: 8e18, cost: 1e23, multiplier: 1.48, requiredWorld: 'genesis' },
  god_eater: { name: "God Eater", baseSps: 5e22, cost: 5e26, multiplier: 1.50, requiredWorld: 'pantheon_of_ashes' },
  deific_remnant: { name: "Deific Remnant", baseSps: 4e23, cost: 3e27, multiplier: 1.52, requiredWorld: 'pantheon_of_ashes', bonus: {type: 'resonance_effectiveness_per_level', value: 0.01}},
  time_leech: { name: "Time Leech", baseSps: 2e28, cost: 1e32, multiplier: 1.55, requiredWorld: 'chronos_fault', bonus: {type: 'ritual_cooldown_reducer_per_level', value: 0.001}},
  eon_devourer: { name: "Eon Devourer", baseSps: 1.5e29, cost: 8e32, multiplier: 1.58, requiredWorld: 'chronos_fault' },
  alpha_omega: { name: "Alpha & Omega", baseSps: 1e35, cost: 1e39, multiplier: 1.65, requiredWorld: 'omega_point', bonus: {type: 'ascension_shard_bonus_per_level', value: 0.005}},

  // Tier 14 (COSMIC): True Infinity
  concept_of_death: {
    name: "Concept of Death",
    baseSps: 1e38,
    cost: 1e44,
    multiplier: 1.70,
    requiredWorld: 'true_infinity'
  },
  the_last_question: {
    name: "The Last Question",
    baseSps: 1e41,
    cost: 1e48,
    multiplier: 1.80,
    requiredWorld: 'true_infinity',
    bonus: { type: 'ascension_shard_bonus', value: 1.0 } // Doubles shard gain
  }
};

const artifacts = {
  shard_of_avarice: {
    name: "Shard of Avarice",
    desc: "Your manual harvests are 100% more effective.",
    cost: 1,
    requiredWorld: 'nether_plains',
    bonus: { type: 'spc_multiplier', value: 2 }
  },
  demonic_pact: {
    name: "Demonic Pact",
    desc: "All minions are 25% more effective.",
    cost: 2,
    requiredWorld: 'nether_plains',
    bonus: { type: 'sps_multiplier', value: 1.25 }
  },
  unholy_effigy: {
    name: "Unholy Effigy",
    desc: "Reduces the cost of all minions by 5%.",
    cost: 3,
    requiredWorld: 'nether_plains',
    bonus: { type: 'minion_cost_reducer', value: 0.95 }
  },
  brazier_of_cinders: {
    name: "Brazier of Cinders",
    desc: "Ash Golems and Cinder Wraiths produce 100% more souls.",
    cost: 8,
    requiredWorld: 'ashen_wastes',
    bonus: { type: 'minion_specific_multiplier', target: ['ash_golem', 'cinder_wraith'], value: 2 }
  },
  ember_locket: {
    name: "Ember Locket",
    desc: "Empower Harvest upgrade is 10% cheaper.",
    cost: 12,
    requiredWorld: 'ashen_wastes',
    bonus: { type: 'upgrade_cost_reducer', target: 'click', value: 0.90 }
  },
  philosophers_stone: {
    name: "Philosopher's Stone",
    desc: "Sacrificing souls yields 20% more Dark Essence.",
    cost: 15,
    requiredWorld: 'stygian_depths',
    bonus: { type: 'essence_multiplier', value: 1.2 }
  },
  charons_oar: {
    name: "Charon's Oar",
    desc: "Each world unlocked increases global soul gain by 5%.",
    cost: 20,
    requiredWorld: 'stygian_depths',
    bonus: { type: 'global_multiplier_per_world', value: 0.05 }
  },
  crown_of_the_damned: {
    name: "Crown of the Damned",
    desc: "Gain 1% more souls for each unique Artifact you own.",
    cost: 25,
    requiredWorld: 'burning_hells',
    bonus: { type: 'global_multiplier_per_artifact', value: 0.01 }
  },
  hellfire_talisman: {
    name: "Hellfire Talisman",
    desc: "Ritual effects last 25% longer.",
    cost: 40,
    requiredWorld: 'burning_hells',
    bonus: { type: 'ritual_duration_multiplier', value: 1.25 }
  },
  book_of_belial: {
    name: "Book of Belial",
    desc: "Rituals cooldown 10% faster.",
    cost: 50,
    requiredWorld: 'burning_hells',
    bonus: { type: 'ritual_cooldown_reducer', value: 0.90 }
  },
  heart_of_winter: {
    name: "Heart of Winter",
    desc: "All 'cold' themed minions are 200% more effective.",
    cost: 75,
    requiredWorld: 'frozen_abyss',
    bonus: { type: 'minion_specific_multiplier', target: ['frost_lich', 'icefiend', 'glacial_titan'], value: 3 }
  },
  hourglass_of_ages: {
    name: "Hourglass of Ages",
    desc: "Gain a 10% bonus to Abyssal Shards when you Ascend.",
    cost: 100,
    requiredWorld: 'frozen_abyss',
    bonus: { type: 'ascension_shard_bonus', value: 0.10 }
  },
  broken_halo: {
    name: "Broken Halo",
    desc: "Fallen Angels and Corrupted Cherubs also boost SPC by 0.01% of their SPS.",
    cost: 150,
    requiredWorld: 'celestial_ruins',
    bonus: { type: 'minion_sps_to_spc', target: ['fallen_angel', 'corrupted_cherub'], value: 0.0001 }
  },
  scroll_of_heresy: {
    name: "Scroll of Heresy",
    desc: "Soul Resonance upgrade is 25% more effective.",
    cost: 200,
    requiredWorld: 'celestial_ruins',
    bonus: { type: 'resonance_bonus_enhancer', value: 0.25 }
  },
  voidforged_gauntlet: {
    name: "Voidforged Gauntlet",
    desc: "Gain 0.5% more souls for each Ascension.",
    cost: 500,
    requiredWorld: 'void_threshold',
    bonus: { type: 'global_multiplier_per_ascension', value: 0.005 }
  },
  eye_of_the_abyss: {
    name: "Eye of the Abyss",
    desc: "The Abyssal Shard soul gain bonus is 10% stronger.",
    cost: 750,
    requiredWorld: 'void_threshold',
    bonus: { type: 'prestige_bonus_enhancer', value: 1.1 }
  },
  singularity_shard: {
    name: "Singularity Shard",
    desc: "All soul gains are multiplied by the number of ascensions you have (min 1).",
    cost: 2500,
    requiredWorld: 'singularity',
    bonus: { type: 'global_multiplier_by_ascensions' }
  },
  final_testament: {
    name: "Final Testament",
    desc: "Doubles the effectiveness of ALL other artifacts.",
    cost: 10000,
    requiredWorld: 'singularity',
    bonus: { type: 'meta_artifact_doubler' }
  },
  aetheric_lens: {
    name: "Aetheric Lens",
    desc: "Dark Essence sacrifices have a 1% chance to yield 100x the essence.",
    cost: 25000,
    requiredWorld: 'event_horizon',
    bonus: { type: 'essence_jackpot_chance', value: 0.01, multiplier: 100 }
  },
  covenant_of_the_first: {
    name: "Covenant of the First",
    desc: "Global soul gain is multiplied by your ascensions SQUARED.",
    cost: 75000,
    requiredWorld: 'genesis',
    bonus: { type: 'global_multiplier_by_ascensions_squared' }
  },
  paragon_soul: {
    name: "Paragon Soul",
    desc: "For every 100 Abyssal Shards, gain a +10% global soul multiplier.",
    cost: 200000,
    requiredWorld: 'pantheon_of_ashes',
    bonus: { type: 'global_multiplier_per_100_shards', value: 0.1 }
  },
  temporal_anchor: {
    name: "Temporal Anchor",
    desc: "After rituals expire, their effects linger at 10% effectiveness.",
    cost: 500000,
    requiredWorld: 'chronos_fault',
    bonus: { type: 'lingering_rituals', value: 0.1 }
  },

  // --- COSMIC ARTIFACTS (Post-Omega Point) ---
  eye_of_chaos: {
    name: "Eye of Chaos",
    desc: "For every unique minion type you own, gain a +10% global soul multiplier.",
    cost: 1e6,
    requiredWorld: 'omega_point',
    bonus: { type: 'global_multiplier_per_unique_minion', value: 0.1 }
  },
  the_final_word: {
    name: "The Final Word",
    desc: "You may now gain souls beyond True Infinity. The game no longer has an end.",
    cost: 1e7,
    requiredWorld: 'true_infinity',
    bonus: { type: 'unlock_true_endgame' }
  }
};

const rituals = { blood_frenzy: { name: "Blood Frenzy", desc: "Double your Souls Per Click for 30 seconds.", cost: 10000, cooldown: 300, requiredWorld: 'nether_plains', effect: {type: 'spc_multiplier', value: 2, duration: 30}}, demonic_horde: { name: "Demonic Horde", desc: "Double your Souls Per Second for 60 seconds.", cost: 50000, cooldown: 600, requiredWorld: 'nether_plains', effect: {type: 'sps_multiplier', value: 2, duration: 60}}, soul_sear: { name: "Soul Sear", desc: "Instantly gain souls equal to 10 minutes of SPS.", cost: 1e6, cooldown: 1800, requiredWorld: 'ashen_wastes', effect: {type: 'gain_sps_seconds', value: 600}}, essence_theft: { name: "Essence Theft", desc: "Instantly gain 1 Dark Essence.", cost: 1e8, cooldown: 3600, requiredWorld: 'stygian_depths', effect: {type: 'gain_essence', value: 1}}, unholy_power: { name: "Unholy Power", desc: "All soul gains are tripled for 2 minutes.", cost: 1e11, cooldown: 1800, requiredWorld: 'burning_hells', effect: {type: 'global_multiplier', value: 3, duration: 120}}, devils_bargain:{ name: "Devil's Bargain", desc: "All minion costs are halved for 5 minutes.", cost: 1e13, cooldown: 7200, requiredWorld: 'burning_hells', effect: {type: 'temp_minion_cost_reducer', value: 0.5, duration: 300}}, glacial_freeze:{ name: "Glacial Freeze",desc: "For 1 minute, all clicks also generate 1% of your SPS.", cost: 1e16, cooldown: 3600, requiredWorld: 'frozen_abyss', effect: {type: 'add_sps_to_spc', value: 0.01, duration: 60}}, divine_curse: { name: "Divine Curse", desc: "For 90s, all soul gains are multiplied by your Dark Essence count.", cost: 1e20, cooldown: 10800, requiredWorld: 'celestial_ruins', effect: {type: 'multiplier_by_essence', duration: 90}}, void_rupture: { name: "Void Rupture", desc: "Instantly gain 1% of the souls required for the next world.", cost: 1e24, cooldown: 86400, requiredWorld: 'void_threshold', effect: {type: 'gain_souls_for_next_world', value: 0.01}}, entropic_cascade: { name: "Entropic Cascade", desc: "For 30 seconds, your total soul gain is SQUARED.", cost: 1e28, cooldown: 43200, requiredWorld: 'pantheon_of_ashes', effect: {type: 'square_all_gain', duration: 30}}, ascendants_echo: { name: "Ascendant's Echo", desc: "Instantly gain Shards equal to 10% of your next Ascension without resetting.", cost: 1e34, cooldown: 172800, requiredWorld: 'chronos_fault', effect: {type: 'gain_shards_no_reset', value: 0.1}}, };
const worlds = { nether_plains: { name: "Nether Plains", unlockCost: 0, perk: "Unlocks basic minions.", bonus: { type: 'none' }, lore:"A swirling gray expanse where the weakest and most plentiful souls wander, ripe for the taking." }, ashen_wastes: { name: "Ashen Wastes", unlockCost: 5e4, perk: "Unlocks fire-themed minions.", bonus: { type: 'sps_multiplier', value: 1.25 }, lore:"Endless dunes of gray ash under a perpetually smoldering sky. The air crackles with embers and lost rage."}, stygian_depths: { name: "Stygian Depths", unlockCost: 2.5e5, perk: "Unlocks aquatic demons.", bonus: { type: 'spc_multiplier', value: 1.5 }, lore:"A lightless, crushing ocean of liquid despair. Only things born of sorrow can survive here."}, burning_hells: { name: "The Burning Hells", unlockCost: 7.5e5, perk: "Unlocks powerful lords of hell.", bonus: { type: 'global_multiplier', value: 1.2 }, lore:"A realm of jagged obsidian and rivers of fire, ruled by ancient beings of pure malice."}, frozen_abyss: { name: "The Frozen Abyss", unlockCost: 1.5e6, perk: "Unlocks ice-themed titans.", bonus: { type: 'sps_multiplier', value: 1.5 }, lore:"A place so cold that even souls freeze solid. The silence here is a weapon."}, celestial_ruins: { name: "Celestial Ruins", unlockCost: 8e6, perk: "Harvest the souls of fallen celestials.", bonus: { type: 'essence_bonus_chance', value: 0.001 }, lore:"The shattered remains of a forgotten heaven. The souls here are potent, tinged with both divinity and regret."}, void_threshold: { name: "Void Threshold", unlockCost: 2.5e7, perk: "Enables Ascension. Unlocks void beings.", bonus: { type: 'ascension_unlock' }, lore:"The precipice of non-existence. Here, you learn that to truly grow, you must first become nothing."}, singularity: { name: "The Singularity", unlockCost: 1e9, perk: "Boosts essence gain x2.", bonus: { type: 'essence_multiplier', value: 2 }, lore:"All matter, energy, and souls compressed into a single, screaming point of infinite density."}, event_horizon: { name: "Event Horizon", unlockCost: 1e11, perk: "Beyond this, only shards matter.", bonus: { type: 'ascension_shard_bonus', value: 0.25 }, lore:"The point of no return. The power of your previous harvests is the only thing that has meaning now."}, genesis: { name: "Genesis", unlockCost: 1e13, perk: "Doubles shard gains.", bonus: { type: 'ascension_shard_bonus', value: 1 }, lore:"The spark that came before the first bang. A realm of pure potential, waiting to be consumed and remade."}, pantheon_of_ashes: { name: "Pantheon of Ashes", unlockCost: 1e18, perk: "Soul Resonance is twice as effective.", bonus: { type: 'resonance_bonus_enhancer', value: 1}, lore:"The graveyard of forgotten gods. Their fading power infuses every soul you claim here."}, chronos_fault: { name: "Chronos' Fault", unlockCost: 1e25, perk: "All ritual cooldowns are halved.", bonus: { type: 'ritual_cooldown_reducer', value: 0.5}, lore:"A crack in time itself. The laws of cause and effect are suggestions, not rules."}, omega_point: { name: "Omega Point", unlockCost: 1e33, perk: "All soul gains x10.", bonus: { type: 'global_multiplier', value: 10 }, lore:"The final moment of the final universe. All that was, is, and ever will be is harvested in a single, glorious instant."}, true_infinity:   { name: "True Infinity",     unlockCost: 1e42,   perk: "You have consumed all. There is nothing left.", bonus: { type: 'none' }, lore:"You sit on a throne of cosmic dust, the last thinking being at the end of time. There is nothing left to harvest... or is there?"}, };
const items = { chipped_dagger: { name: "Chipped Dagger", type: "weapon", rarity: "common", desc: "+10% Souls Per Click.", bonus: { type: 'spc_multiplier', value: 1.10 } }, soul_cleaver: { name: "Soul Cleaver", type: "weapon", rarity: "uncommon", desc: "+25% Souls Per Click.", bonus: { type: 'spc_multiplier', value: 1.25 } }, abyssal_scythe: { name: "Abyssal Scythe", type: "weapon", rarity: "rare", desc: "+50% Souls Per Click. Your SPC contributes 0.01% to your SPS.", bonus: { type: 'spc_multiplier', value: 1.50, and: { type: 'spc_to_sps', value: 0.0001 } } }, blade_of_the_damned: { name: "Blade of the Damned", type: "weapon", rarity: "legendary", desc: "Doubles Souls Per Click. Clicks have a 1% chance to also grant 1 Dark Essence.", bonus: { type: 'spc_multiplier', value: 2.0, and: { type: 'spc_essence_chance', value: 0.01 } } }, cracked_effigy: { name: "Cracked Effigy", type: "idol", rarity: "common", desc: "+10% Souls Per Second.", bonus: { type: 'sps_multiplier', value: 1.10 } }, demonic_relic: { name: "Demonic Relic", type: "idol", rarity: "uncommon", desc: "+25% Souls Per Second.", bonus: { type: 'sps_multiplier', value: 1.25 } }, void_totem: { name: "Void Totem", type: "idol", rarity: "rare", desc: "+50% Souls Per Second. All minion costs are reduced by 5%.", bonus: { type: 'sps_multiplier', value: 1.50, and: { type: 'minion_cost_reducer', value: 0.95 } } }, heart_of_the_horde: { name: "Heart of the Horde", type: "idol", rarity: "legendary", desc: "Doubles Souls Per Second. Gain +1% SPS for every 10 ascensions.", bonus: { type: 'sps_multiplier', value: 2.0, and: { type: 'sps_per_10_ascensions', value: 0.01 } } }, faded_rune: { name: "Faded Rune", type: "sigil", rarity: "common", desc: "Gain 5% more Dark Essence from sacrifices.", bonus: { type: 'essence_multiplier', value: 1.05 } }, starlit_glyph: { name: "Starlit Glyph", type: "sigil", rarity: "uncommon", desc: "+10% Abyssal Shards gained on Ascension.", bonus: { type: 'ascension_shard_bonus', value: 0.10 } }, covenant_of_souls: { name: "Covenant of Souls", type: "sigil", rarity: "rare", desc: "Soul Resonance is 20% more effective.", bonus: { type: 'resonance_bonus_enhancer', value: 0.20 } }, mark_of_the_first: { name: "Mark of the First", type: "sigil", rarity: "legendary", desc: "Your first purchase of each minion per run is free.", bonus: { type: 'first_minion_free' } }, iron_mask: { name: "Iron Mask", type: "helm", rarity: "common", desc: "In PvP Duels, you take 10% less passive damage.", bonus: { type: 'pvp_defense', value: 0.90 } }, gaze_of_terror: { name: "Gaze of Terror", type: "helm", rarity: "uncommon", desc: "In PvP Duels, the opponent's passive damage is reduced by 25%.", bonus: { type: 'pvp_defense', value: 0.75 } }, crown_of_dominance: { name: "Crown of Dominance", type: "helm", rarity: "rare", desc: "In PvP Duels, your click damage is increased by 50%.", bonus: { type: 'pvp_offense', value: 1.50 } }, helm_of_the_conqueror: { name: "Helm of the Conqueror", type: "helm", rarity: "legendary", desc: "Start PvP Duels with a 2-second head start before the opponent deals damage.", bonus: { type: 'pvp_headstart', value: 2 } }, };
const potions = { draught_of_might: { name: "Draught of Might", desc: "For 60 seconds, your Souls Per Click is increased by 25% of your Souls Per Second.", cost: 1e6, effect: { type: 'add_sps_to_spc_flat', value: 0.25, duration: 60 } }, ichor_of_wealth: { name: "Ichor of Wealth", desc: "Instantly gain souls equal to 30 minutes of your current SPS.", cost: 1e7, effect: { type: 'gain_sps_seconds_flat', value: 1800 } }, elixir_of_wisdom: { name: "Elixir of Wisdom", desc: "For 5 minutes, all minions cost 10% less.", cost: 1e8, effect: { type: 'temp_minion_cost_reducer_flat', value: 0.90, duration: 300 } }, brew_of_the_void: { name: "Brew of the Void", desc: "Instantly gain 2 Dark Essence.", cost: 1e9, costType: 'souls_and_shards', shardsCost: 1, effect: { type: 'gain_essence_flat', value: 2 } } };
// =================================================================
// GAME STATE & CORE LOGIC
// =================================================================
let gameState = {}; let duelState = {};
const antiCheatState = { clickTimestamps: [], clickIntervals: [], punishmentLevel: 0, isLockedOut: false };
function getDefaultGameState() { const newMinionsState = {}; for (const id in minions) { newMinionsState[id] = { level: 0, cost: minions[id].cost }; } return { playerName: "Unnamed", souls: 0, lifetimeSouls: 0, darkEssence: 0, abyssalShards: 0, ascensions: 0, currentWorld: 'nether_plains', unlockedWorlds: ['nether_plains'], stats: { sps: 0, spc: 1 }, upgrades: { click: { level: 1, cost: 10, multiplier: 1.12 }, sacrifice: { cost: 1000, multiplier: 2.5 }, resonance: { level: 0, cost: 5, multiplier: 2 }, }, minions: newMinionsState, ownedArtifacts: {}, activeRituals: {}, potions: {}, activePotions: {}, inventory: [], equipped: { weapon: null, idol: null, sigil: null, helm: null, }, nextCacheTime: 0, pvpWins: 0, pvpLosses: 0, attackLog: [], raidCooldownEnd: 0, }; }
// =================================================================
// INITIALIZATION & GAME LOOP
// =================================================================
window.onload = function() {
    loadGame();
    calculateStats();
    renderAll();
    initRift();
    let tickCounter = 0;
    const TICKS_PER_SECOND = 10;
    setInterval(() => {
        const now = Date.now();
        const passiveGain = gameState.stats.sps / TICKS_PER_SECOND;
        gameState.souls += passiveGain;
        gameState.lifetimeSouls += passiveGain;
        updateDynamicDisplays();
        tickCounter++;
        if (tickCounter % TICKS_PER_SECOND === 0) {
            let statsChanged = updateEffectTimers(now);
            if(statsChanged) {
                calculateStats();
                renderAll();
            } else {
                checkButtons();
            }
            updateAscensionPreview();
            updateCacheTimer();
            updateRaidCooldownDisplay();
        }
        if (tickCounter % (TICKS_PER_SECOND * 120) === 0) {
            saveGame();
        }
    }, 1000 / TICKS_PER_SECOND);
};
function createProfile() { const nameInput = document.getElementById('playerNameInput'); if (nameInput.value.trim() === '') { alert("A name is required."); return; } gameState.playerName = nameInput.value.trim(); document.getElementById('profile-setup').style.display = 'none'; document.getElementById('game-container').style.display = 'block'; audio.bgm.play().catch(e=>console.log("Audio autoplay blocked.")); saveGame(); renderAll(); }
async function saveGame() {
    localStorage.setItem('soulCollectorSave_v3', JSON.stringify(gameState));
    if (!supabaseClient || gameState.playerName === "Unnamed") {
        return;
    }

    const publicData = {
        name: gameState.playerName,
        lifetimeSouls: gameState.lifetimeSouls,
        ascensions: gameState.ascensions,
        pvpWins: gameState.pvpWins,
        pvpLosses: gameState.pvpLosses,
        bin_id: gameState.playerName,
    };

    try {
        const { error } = await supabaseClient
            .from('players')
            .upsert(publicData, { onConflict: 'name' }); 
        if (error) throw error;
        console.log("PvP data synced with Supabase.");
    } catch (error) {
        console.error("Failed to sync PvP data with Supabase:", error.message);
    }
}
function loadGame() {
  const savedGame = localStorage.getItem('soulCollectorSave_v3');
  const defaultState = getDefaultGameState();

  if (savedGame) {
    try {
      let loadedState = JSON.parse(savedGame);
      gameState = deepMerge(defaultState, loadedState);
      document.getElementById('game-container').style.display = 'block';
      audio.bgm.play().catch(e => {});
    } catch (e) {
      console.error("Error parsing save. Starting fresh.", e);
      gameState = defaultState;
      document.getElementById('profile-setup').style.display = 'flex';
    }

    // Load audio settings
    audio.bgm.muted = localStorage.getItem('musicMuted') === 'true';
    audio.sfxMuted = localStorage.getItem('sfxMuted') === 'true';
    document.getElementById('musicStatus').innerText = `Status: ${audio.bgm.muted ? 'OFF' : 'ON'}`;
    document.getElementById('sfxStatus').innerText = `Status: ${audio.sfxMuted ? 'OFF' : 'ON'}`;
  } else {
    gameState = defaultState;
    document.getElementById('profile-setup').style.display = 'flex';
  }
}

function deepMerge(target, source) {
    for (const key in source) {
        if (source[key] instanceof Object && key in target) {
            Object.assign(source[key], deepMerge(target[key], source[key]));
        }
    }
    Object.assign(target || {}, source);
    return target;
}
// =================================================================
// CORE GAMEPLAY FUNCTIONS
// =================================================================
function harvestSoul() {
    if (antiCheatState.isLockedOut) return;
    const gain = gameState.stats.spc;
    gameState.souls += gain;
    gameState.lifetimeSouls += gain;
    const btn = document.querySelector('.action-btn');
    btn.classList.remove('thump-animation');
    void btn.offsetWidth;
    btn.classList.add('thump-animation');
    playSound('harvest');
    const rect = btn.getBoundingClientRect();
    for (let i = 0; i < 5; i++) {
        const particle = document.createElement('div');
        particle.className = 'soul-particle';
        document.body.appendChild(particle);
        particle.style.left = `${rect.left + rect.width / 2}px`;
        particle.style.top = `${rect.top + rect.height / 2}px`;
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * 80 + 50;
        particle.style.setProperty('--x', `${Math.cos(angle) * distance}px`);
        particle.style.setProperty('--y', `${Math.sin(angle) * distance}px`);
        setTimeout(() => particle.remove(), 800);
    }
    const worldBonus = worlds[gameState.currentWorld].bonus;
    if (worldBonus.type === 'essence_bonus_chance' && Math.random() < worldBonus.value) gameState.darkEssence += 1;
    const weaponId = gameState.equipped.weapon;
    if (weaponId && items[weaponId]) {
        let bonus = items[weaponId].bonus;
        do {
            if (bonus.type === 'spc_essence_chance' && Math.random() < bonus.value) gameState.darkEssence += 1;
            bonus = bonus.and ? bonus.and : null;
        } while (bonus);
    }
    
    runAntiCheatChecks(); 
    
    updateDynamicDisplays();
} 
function buyUpgrade(type) { const upgrade = gameState.upgrades[type]; if (type === 'click' || type === 'sacrifice') { if (gameState.souls < upgrade.cost) return; gameState.souls -= upgrade.cost; if (type === 'click') { upgrade.level++; } else if (type === 'sacrifice') {
    let essenceGain = 1;
    let multi = 1;
    Object.keys(gameState.ownedArtifacts).forEach(id => {
        const bonus = artifacts[id]?.bonus;
        if (bonus && bonus.type === 'essence_multiplier') multi *= bonus.value;
    });
    essenceGain *= multi;
    if (gameState.equipped.sigil && items[gameState.equipped.sigil]?.bonus.type === 'essence_multiplier') essenceGain *= items[gameState.equipped.sigil].bonus.value;
    gameState.darkEssence += Math.floor(essenceGain);
    upgrade.cost = Math.floor(upgrade.cost * 1.15);
} } else if (type === 'resonance') { if (gameState.darkEssence < upgrade.cost) return; gameState.darkEssence -= upgrade.cost; upgrade.level++; } audio.click.play().catch(e => {}); calculateStats(); renderAll(); playSound('upgrade'); saveGame(); }
function buyMinion(id) {
  const minionData = minions[id];
  const playerMinion = gameState.minions[id];

  if (gameState.souls >= playerMinion.cost) {
    gameState.souls -= playerMinion.cost;
    playerMinion.level++;
    playSound('upgrade');

    audio.click.play().catch(e => {});

    calculateStats();
    renderMinions();
    checkButtons();
    saveGame();
  }
}

function buyArtifact(id) { const artifactData = artifacts[id]; if (gameState.darkEssence >= artifactData.cost && !gameState.ownedArtifacts[id]) { gameState.darkEssence -= artifactData.cost; gameState.ownedArtifacts[id] = true; playSound('upgrade'); audio.click.play().catch(e => {}); calculateStats(); renderAll(); saveGame(); } }
function activateRitual(id) {
  const ritualData = rituals[id];
  const effect = ritualData.effect;

  let ritualDuration = effect.duration || 0;
  let ritualCooldown = ritualData.cooldown;

  // Apply artifact bonuses
  Object.keys(gameState.ownedArtifacts).forEach(artId => {
    const bonus = artifacts[artId]?.bonus;
    if (bonus) {
      if (bonus.type === 'ritual_cooldown_reducer') {
        ritualCooldown *= bonus.value;
      }
      if (bonus.type === 'ritual_duration_multiplier') {
        ritualDuration *= bonus.value;
      }
    }
  });

  // Check if ritual can be activated
  if (gameState.souls >= ritualData.cost && !gameState.activeRituals[id]) {
    gameState.souls -= ritualData.cost;

    // Apply ritual effects
    if (effect.type === 'gain_essence') {
      gameState.darkEssence += effect.value;
    }

    if (effect.type === 'gain_sps_seconds') {
      gameState.souls += gameState.stats.sps * effect.value;
    }

    if (effect.type === 'gain_souls_for_next_world') {
      const worldKeys = Object.keys(worlds);
      const currentWorldIndex = worldKeys.indexOf(gameState.currentWorld);
      const nextWorldId = worldKeys[currentWorldIndex + 1];

      if (nextWorldId && worlds[nextWorldId]) {
        gameState.souls += worlds[nextWorldId].unlockCost * effect.value;
      }
    }

    if (effect.type === 'gain_shards_no_reset') {
      gameState.abyssalShards += Math.floor(calculateShardsOnAscend() * effect.value);
    }

    // Activate ritual
    const now = Date.now();
    gameState.activeRituals[id] = {
      cooldownEndTime: now + ritualCooldown * 1000,
      buffEndTime: ritualDuration > 0 ? now + ritualDuration * 1000 : null
    };

    // Trigger updates
    audio.click.play().catch(e => {});
    playSound('upgrade');
    calculateStats();
    renderAll();
    saveGame();
  }
}

function performAscension() {
  // Ensure the Void Threshold world is unlocked
  if (!gameState.unlockedWorlds.includes('void_threshold')) return;

  const shardsGained = calculateShardsOnAscend();

  if (shardsGained < 1) {
    alert("You have not harvested enough souls to gain any Abyssal Shards.");
    return;
  }

  const oldState = gameState;
  gameState = getDefaultGameState();

  // Preserve important data across ascension
  gameState.playerName = oldState.playerName;
  gameState.abyssalShards = oldState.abyssalShards + shardsGained;
  gameState.ownedArtifacts = oldState.ownedArtifacts;
  gameState.ascensions = oldState.ascensions + 1;
  gameState.upgrades.resonance = oldState.upgrades.resonance;
  gameState.pvpWins = oldState.pvpWins;
  gameState.pvpLosses = oldState.pvpLosses;

  // Post-ascension actions
  audio.ascend.play().catch(e => {});
  playSound('ascend')
  calculateStats();
  renderAll();
  showScreen('altar');
  saveGame();
}

function calculateShardsOnAscend() { let resonanceEffect = 0.05 * (1 + (artifacts.scroll_of_heresy && gameState.ownedArtifacts['scroll_of_heresy'] ? artifacts.scroll_of_heresy.bonus.value : 0)); let resonanceBonus = 1 + (gameState.upgrades.resonance.level * resonanceEffect); let baseShards = Math.floor(Math.pow(gameState.lifetimeSouls / 1e7, 0.5)); let totalShards = baseShards * resonanceBonus; let shardMultiplier = 1; Object.keys(gameState.ownedArtifacts).forEach(id => { const bonus = artifacts[id]?.bonus; if(bonus && bonus.type === 'ascension_shard_bonus') shardMultiplier += bonus.value; }); gameState.unlockedWorlds.forEach(id => { const bonus = worlds[id]?.bonus; if(bonus && bonus.type === 'ascension_shard_bonus') shardMultiplier += bonus.value; }); totalShards *= shardMultiplier; return Math.floor(totalShards); }
function updateAscensionPreview() { document.getElementById('shardsOnAscend').innerText = formatNumber(calculateShardsOnAscend()); }
function calculateStats() { let baseSpc = 1 + (gameState.upgrades.click.level - 1) * 2.5; let sps = 0, spc_multiplier = 1, sps_multiplier = 1, global_multiplier = 1, minionCostFactor = 1, clickUpgradeCostFactor = 1, prestigeBonusEnhancer = 1; let tempMinionCostFactor = 1; let isGainSquared = false; for (const slot in gameState.equipped) { const itemId = gameState.equipped[slot]; if (itemId && items[itemId]) { let bonus = items[itemId].bonus; do { if (bonus.type === 'minion_cost_reducer') minionCostFactor *= bonus.value; bonus = bonus.and ? bonus.and : null; } while (bonus); } } for (const id in gameState.activeRituals) { const ritualState = gameState.activeRituals[id]; if (Date.now() < ritualState.buffEndTime) { const effect = rituals[id].effect; if (effect.type === 'spc_multiplier') spc_multiplier *= effect.value; if (effect.type === 'sps_multiplier') sps_multiplier *= effect.value; if (effect.type === 'global_multiplier') global_multiplier *= effect.value; if (effect.type === 'temp_minion_cost_reducer') tempMinionCostFactor *= effect.value; if (effect.type === 'multiplier_by_essence') global_multiplier *= (gameState.darkEssence || 1); if (effect.type === 'square_all_gain') isGainSquared = true; } } Object.keys(gameState.ownedArtifacts).forEach(id => { const bonus = artifacts[id]?.bonus; if (!bonus) return; if (bonus.type === 'minion_cost_reducer') minionCostFactor *= bonus.value; if (bonus.type === 'upgrade_cost_reducer' && bonus.target === 'click') clickUpgradeCostFactor *= bonus.value; if (bonus.type === 'prestige_bonus_enhancer') prestigeBonusEnhancer *= bonus.value; if (bonus.type === 'global_multiplier_per_artifact') global_multiplier += (bonus.value * Object.keys(gameState.ownedArtifacts).length); if (bonus.type === 'global_multiplier_per_world') global_multiplier += (bonus.value * gameState.unlockedWorlds.length); if (bonus.type === 'global_multiplier_per_ascension') global_multiplier += (bonus.value * gameState.ascensions); if (bonus.type === 'global_multiplier_by_ascensions' && gameState.ascensions > 0) global_multiplier *= gameState.ascensions; if (bonus.type === 'global_multiplier_per_unique_minion') {
    const uniqueMinionsOwned = Object.keys(gameState.minions).filter(id => gameState.minions[id].level > 0).length;
    global_multiplier *= (1 + (uniqueMinionsOwned * bonus.value));
} }); for (const id in gameState.minions) { if (gameState.minions[id].level > 0) { let minionSps = gameState.minions[id].level * minions[id].baseSps; Object.keys(gameState.ownedArtifacts).forEach(artId => { const bonus = artifacts[artId]?.bonus; if (bonus && bonus.type === 'minion_specific_multiplier' && bonus.target.includes(id)) minionSps *= bonus.value; }); sps += minionSps; } } for (const slot in gameState.equipped) { const itemId = gameState.equipped[slot]; if (itemId && items[itemId]) { let bonus = items[itemId].bonus; do { if (bonus.type === 'spc_multiplier') spc_multiplier *= bonus.value; if (bonus.type === 'sps_multiplier') sps_multiplier *= bonus.value; if (bonus.type === 'sps_per_10_ascensions') sps_multiplier += Math.floor(gameState.ascensions / 10) * bonus.value; bonus = bonus.and ? bonus.and : null; } while (bonus); } } const worldBonus = worlds[gameState.currentWorld].bonus; if (worldBonus.type === 'sps_multiplier') sps_multiplier *= worldBonus.value; if (worldBonus.type === 'spc_multiplier') spc_multiplier *= worldBonus.value; if (worldBonus.type === 'global_multiplier') global_multiplier *= worldBonus.value; const prestige_bonus = Math.pow(1.1 * prestigeBonusEnhancer, gameState.abyssalShards); global_multiplier *= prestige_bonus; let final_sps = sps * sps_multiplier * global_multiplier; let final_spc = baseSpc * spc_multiplier * global_multiplier; if (isGainSquared) { final_sps = Math.pow(final_sps, 2); final_spc = Math.pow(final_spc, 2); } gameState.stats.sps = final_sps; gameState.stats.spc = final_spc; gameState.upgrades.click.cost = Math.floor(10 * Math.pow(gameState.upgrades.click.multiplier, gameState.upgrades.click.level - 1) * clickUpgradeCostFactor); for (const minionId in minions) { const minionData = minions[minionId]; const playerMinion = gameState.minions[minionId]; const baseMinionCost = minionData.cost * Math.pow(minionData.multiplier, playerMinion.level); let finalMinionCostFactor = minionCostFactor * tempMinionCostFactor; const sigilId = gameState.equipped.sigil; if (sigilId && items[sigilId] && items[sigilId].bonus.type === 'first_minion_free' && playerMinion.level === 0) finalMinionCostFactor = 0; playerMinion.cost = Math.floor(baseMinionCost * finalMinionCostFactor); } }
// =================================================================
// UI RENDERING & UPDATES
// =================================================================
function renderAll() { if (!gameState || !gameState.currentWorld) return; document.getElementById('playerName-display').innerText = gameState.playerName; document.getElementById('world-title').innerText = worlds[gameState.currentWorld].name; renderAltar(); renderMinions(); renderBrewery(); renderInventory(); renderArtifacts(); renderRituals(); renderMap(); renderAscensionScreen(); renderPvpLog(); updateDynamicDisplays(); checkButtons(); }
function updateDynamicDisplays() { document.getElementById('souls-display').innerText = formatNumber(gameState.souls); document.getElementById('essence-display').innerText = formatNumber(gameState.darkEssence); document.getElementById('shards-display').innerText = formatNumber(gameState.abyssalShards); document.getElementById('sps-display').innerText = formatNumber(gameState.stats.sps); document.getElementById('spc-display').innerText = formatNumber(gameState.stats.spc); }
function checkButtons() { document.getElementById('clickUpgradeBtn').disabled = gameState.souls < gameState.upgrades.click.cost; document.getElementById('sacrificeBtn').disabled = gameState.souls < gameState.upgrades.sacrifice.cost; document.getElementById('resonanceUpgradeBtn').disabled = gameState.darkEssence < gameState.upgrades.resonance.cost; for (const id in minions) { const btn = document.getElementById(`minion-btn-${id}`); if(btn) btn.disabled = gameState.souls < gameState.minions[id].cost; } for (const id in artifacts) { const btn = document.getElementById(`artifact-btn-${id}`); if (btn) btn.disabled = gameState.darkEssence < artifacts[id].cost || !!gameState.ownedArtifacts[id]; } for (const id in rituals) { const btn = document.getElementById(`ritual-btn-${id}`); if(btn) btn.disabled = gameState.souls < rituals[id].cost || !!gameState.activeRituals[id]; } document.getElementById('ascendBtn').disabled = !gameState.unlockedWorlds.includes('void_threshold'); }
function showScreen(screenId) { 
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active')); 
    document.getElementById(screenId + '-screen').classList.add('active'); 
    document.querySelectorAll('nav button').forEach(b => b.classList.remove('active')); 
    document.querySelector(`nav button[onclick="showScreen('${screenId}')"]`).classList.add('active'); 
    if(screenId === 'leaderboard') fetchLeaderboard();
    if(screenId === 'pvp') fetchPvpTargets();
    audio.click.play().catch(e => {}); 
    playSound('click');
}
function renderAltar() { document.getElementById('clickLevel').innerText = gameState.upgrades.click.level; document.getElementById('clickCost').innerText = formatNumber(gameState.upgrades.click.cost); document.getElementById('sacrificeCost').innerText = formatNumber(gameState.upgrades.sacrifice.cost); document.getElementById('resonanceLevel').innerText = gameState.upgrades.resonance.level; document.getElementById('resonanceCost').innerText = formatNumber(gameState.upgrades.resonance.cost); }
function renderMinions() {
  const grid = document.getElementById('minion-grid');
  grid.innerHTML = '';

  for (const id in minions) {
    if (gameState.unlockedWorlds.includes(minions[id].requiredWorld)) {
      const m = minions[id];
      const p = gameState.minions[id];

      grid.innerHTML += `
        <button class="upgrade-btn" id="minion-btn-${id}" onclick="buyMinion('${id}')">
          <span class="btn-title">${m.name}</span> (+${formatNumber(m.baseSps)} SPS/lvl)<br>
          <span class="btn-level">Level: ${p.level}</span><br>
          <span class="cost">Cost: <span class="cost-souls">${formatNumber(p.cost)}</span></span>
        </button>
      `;
    }
  }
}

function renderInventory() { const equippedGrid = document.getElementById('equipped-items-grid'); const inventoryGrid = document.getElementById('inventory-items-grid'); if (!equippedGrid || !inventoryGrid) return; equippedGrid.innerHTML = ''; inventoryGrid.innerHTML = ''; if (Object.values(gameState.equipped).every(val => val === null)) { equippedGrid.innerHTML = `<p style="color:var(--dim-color)">No items equipped.</p>`; } else { for (const slot in gameState.equipped) { const itemId = gameState.equipped[slot]; if (itemId) { const item = items[itemId]; equippedGrid.innerHTML += `<div class="upgrade-btn owned" data-tooltip="${item.desc}"><span class="btn-title" style="color:var(--accent-color);">${item.name} (Equipped)</span><br><span>Type: ${slot.charAt(0).toUpperCase() + slot.slice(1)}</span></div>`; } } } if (gameState.inventory.length === 0) { inventoryGrid.innerHTML = `<p style="color:var(--dim-color)">Your inventory is empty. Open an Abyssal Cache!</p>`; } else { gameState.inventory.forEach(itemId => { const item = items[itemId]; inventoryGrid.innerHTML += `<button class="upgrade-btn" onclick="equipItem('${itemId}')"><span class="btn-title">${item.name}</span><br><span>${item.desc}</span><br><span class="cost">Type: <span class="cost-essence">${item.type.charAt(0).toUpperCase() + item.type.slice(1)}</span></span></button>`; }); } }
function equipItem(itemId) { const itemToEquip = items[itemId]; if (!itemToEquip) return; const itemIndex = gameState.inventory.indexOf(itemId); if (itemIndex === -1) return; const slot = itemToEquip.type; const currentlyEquippedId = gameState.equipped[slot]; if (currentlyEquippedId) gameState.inventory.push(currentlyEquippedId); gameState.inventory.splice(itemIndex, 1); gameState.equipped[slot] = itemId; audio.click.play().catch(e => {}); playSound('click'); calculateStats(); renderAll(); saveGame(); }
function renderArtifacts() { const grid = document.getElementById('artifact-grid'); grid.innerHTML = ''; for (const id in artifacts) { if (gameState.unlockedWorlds.includes(artifacts[id].requiredWorld)) { const a = artifacts[id]; const isOwned = !!gameState.ownedArtifacts[id]; grid.innerHTML += `<button class="upgrade-btn ${isOwned ? 'owned' : ''}" id="artifact-btn-${id}" onclick="buyArtifact('${id}')" ${isOwned ? 'disabled' : ''}><span class="btn-title">${a.name}</span><br><span>${a.desc}</span><br><span class="cost">Cost: <span class="cost-essence">${formatNumber(a.cost)}</span></span></button>`; } } }
function renderBrewery() { const recipeGrid = document.getElementById('potion-recipe-grid'); const inventoryGrid = document.getElementById('potion-inventory'); if (!recipeGrid || !inventoryGrid) return; recipeGrid.innerHTML = ''; inventoryGrid.innerHTML = ''; for (const id in potions) { const p = potions[id]; let canAfford = gameState.souls >= p.cost; let costString = `Cost: <span class="cost-souls">${formatNumber(p.cost)}</span>`; if (p.costType === 'souls_and_shards') { canAfford = gameState.souls >= p.cost && gameState.abyssalShards >= p.shardsCost; costString += ` + <span class="cost-shards">${formatNumber(p.shardsCost)} Shards</span>`; } recipeGrid.innerHTML += `<button class="upgrade-btn" onclick="brewPotion('${id}')" ${canAfford ? '' : 'disabled'}><span class="btn-title">${p.name}</span><br><span>${p.desc}</span><br><span class="cost">${costString}</span></button>`; } let hasPotions = false; for (const id in gameState.potions) { if (gameState.potions[id] > 0) { hasPotions = true; const count = gameState.potions[id]; const isActive = gameState.activePotions[id] && Date.now() < gameState.activePotions[id]; let buttonContent = isActive ? `<span style="color:var(--prestige-color); font-style:italic;">Active...</span>` : `<span style="color:var(--accent-color); font-style:italic;">Click to Use</span>`; if (potions[id]) inventoryGrid.innerHTML += `<button class="upgrade-btn" onclick="usePotion('${id}')" ${isActive ? 'disabled' : ''}><span class="btn-title">${potions[id].name} (x${count})</span><br>${buttonContent}</button>`; } } if (!hasPotions) inventoryGrid.innerHTML = `<p style="color:var(--dim-color)">You have no potions. Brew some!</p>`; }
function updateEffectTimers(now) { let shouldRecalculate = false; for (const id in gameState.activeRituals) { if (gameState.activeRituals[id].buffEndTime && now >= gameState.activeRituals[id].buffEndTime) shouldRecalculate = true; } for (const id in gameState.activePotions) { if (now >= gameState.activePotions[id]) shouldRecalculate = true; } return shouldRecalculate; }
function brewPotion(id) { const p = potions[id]; let canAfford = gameState.souls >= p.cost; if (p.costType === 'souls_and_shards') canAfford = gameState.souls >= p.cost && gameState.abyssalShards >= p.shardsCost; if (canAfford) { gameState.souls -= p.cost; if (p.shardsCost) gameState.abyssalShards -= p.shardsCost; gameState.potions[id] = (gameState.potions[id] || 0) + 1; audio.click.play().catch(e => {}); renderBrewery(); checkButtons(); } }
function usePotion(id) { if (gameState.potions[id] > 0) { gameState.potions[id]--; const effect = potions[id].effect; if (effect.type === 'gain_sps_seconds_flat') gameState.souls += gameState.stats.sps * effect.value; if (effect.type === 'gain_essence_flat') gameState.darkEssence += effect.value; if (effect.duration) gameState.activePotions[id] = Date.now() + (effect.duration * 1000); audio.click.play().catch(e => {}); calculateStats(); renderAll(); } }
function updateCacheTimer() { const now = Date.now(); const btn = document.getElementById('abyssal-cache-btn'); if (!btn) return; const timerText = document.getElementById('cache-timer-text'); const readyText = document.getElementById('cache-ready-text'); if (now < gameState.nextCacheTime) { btn.disabled = true; const timeLeft = gameState.nextCacheTime - now; const hours = Math.floor(timeLeft / 3600000); const minutes = Math.floor((timeLeft % 3600000) / 60000); const seconds = Math.floor((timeLeft % 60000) / 1000); timerText.textContent = `${hours}h ${minutes}m ${seconds}s`; readyText.textContent = "ABYSSAL CACHE"; } else { btn.disabled = false; readyText.textContent = "CACHE READY"; timerText.textContent = "Click to Open!"; } }
function openAbyssalCache() { if (Date.now() < gameState.nextCacheTime) return; const itemKeys = Object.keys(items); const randomItemId = itemKeys[Math.floor(Math.random() * itemKeys.length)]; const rewardItem = items[randomItemId]; gameState.inventory.push(randomItemId); const modal = document.getElementById('item-modal-overlay'); const rewardDiv = document.getElementById('item-modal-reward'); rewardDiv.innerHTML = `<div class="item-name" style="color:var(--accent-color);">${rewardItem.name}</div><div class="item-desc">${rewardItem.desc}</div>`; modal.style.display = 'flex'; gameState.nextCacheTime = Date.now() + 4 * 3600000; updateCacheTimer(); audio.ascend.play().catch(e => {}); }
function closeItemModal() { document.getElementById('item-modal-overlay').style.display = 'none'; renderInventory(); }
function playSound(soundName) {
    if (audio.sfxMuted) return; // Don't play if SFX is muted
    const sound = audio[soundName];
    if (sound) {
        sound.currentTime = 0;
        sound.play().catch(e => {}); // Prevents errors if sound is interrupted
    }
}
function closeLoreModal() { document.getElementById('lore-modal-overlay').style.display = 'none'; }
// --- SETTINGS FUNCTIONS ---
function hardReset() {
    if (confirm("ARE YOU SURE? This will completely erase your save file and cannot be undone.")) {
        if (confirm("FINAL WARNING: Are you absolutely certain you want to delete everything?")) {
            localStorage.removeItem('soulCollectorSave_v3');
            window.location.reload();
        }
    }
}

function toggleMusic() {
    audio.bgm.muted = !audio.bgm.muted;
    document.getElementById('musicStatus').innerText = `Status: ${audio.bgm.muted ? 'OFF' : 'ON'}`;
    // Save the setting
    localStorage.setItem('musicMuted', audio.bgm.muted);
}

function toggleSfx() {
    audio.sfxMuted = !audio.sfxMuted;
    document.getElementById('sfxStatus').innerText = `Status: ${audio.sfxMuted ? 'OFF' : 'ON'}`;
    // Save the setting
    localStorage.setItem('sfxMuted', audio.sfxMuted);
}
function renderRituals() { const grid = document.getElementById('ritual-grid'); grid.innerHTML = ''; for (const id in rituals) { if (gameState.unlockedWorlds.includes(rituals[id].requiredWorld)) { const r = rituals[id]; const active = !!gameState.activeRituals[id] && Date.now() < gameState.activeRituals[id].cooldownEndTime; grid.innerHTML += `<button class="upgrade-btn" id="ritual-btn-${id}" onclick="activateRitual('${id}')" ${active ? 'disabled' : ''}><span class="btn-title">${r.name}</span><br><span>${r.desc}</span><br><span class="cost">Cost: <span class="cost-souls">${formatNumber(r.cost)}</span></span></button>`; } } }
function renderMap() { const grid = document.getElementById('map-grid'); grid.innerHTML = ''; for (const id in worlds) { const w = worlds[id]; const isUnlocked = gameState.unlockedWorlds.includes(id); const isActive = gameState.currentWorld === id; const li = document.createElement('li'); if (isActive) li.classList.add('active-world'); let buttonHtml = isUnlocked ? `<button class="upgrade-btn" onclick="travelToWorld('${id}')" ${isActive ? 'disabled' : ''}>Travel</button>` : `<button class="upgrade-btn" onclick="travelToWorld('${id}')" ${gameState.souls < w.unlockCost ? 'disabled' : ''}>Unlock (${formatNumber(w.unlockCost)})</button>`; li.innerHTML = `<div><strong>${w.name}</strong><br><small style="color:var(--prestige-color)">${w.perk}</small></div> ${buttonHtml}`; grid.appendChild(li); } }
function travelToWorld(id) { const isUnlocked = gameState.unlockedWorlds.includes(id); if (isUnlocked) { gameState.currentWorld = id; } else if (gameState.souls >= worlds[id].unlockCost) { gameState.souls -= worlds[id].unlockCost; gameState.unlockedWorlds.push(id); gameState.currentWorld = id; showLore(id); } audio.click.play().catch(e => {}); calculateStats(); renderAll(); saveGame(); }
function showLore(worldId) { const lore = worlds[worldId].lore; if (!lore) return; document.getElementById('lore-modal-title').innerText = `Welcome to ${worlds[worldId].name}`; document.getElementById('lore-modal-text').innerText = lore; document.getElementById('lore-modal-overlay').style.display = 'flex'; }
function renderAscensionScreen() { document.getElementById('ascendBtn').disabled = !gameState.unlockedWorlds.includes('void_threshold'); }

// =================================================================
// PVP & LEADERBOARD FUNCTIONS (FIXED & UPGRADED)
// =================================================================
async function fetchLeaderboard(type = 'lifetimeSouls') {
    const list = document.getElementById('leaderboard-list');
    const title = document.getElementById('leaderboard-title');
    if (!list || !title || !supabaseClient || SUPABASE_URL.includes("YOUR_SUPABASE")) {
        list.innerHTML = `<li>PvP Database not configured. See Step 1 in the tutorial.</li>`;
        return;
    }
    list.innerHTML = '<li><em>Summoning spirits from the datastream...</em></li>';
    try {
        const { data, error } = await supabaseClient
            .from('players')
            .select('*')
            .order(type, { ascending: false })
            .limit(10);
        if (error) throw error;
        
        // Add current player to the list for ranking context if not already present
        let players = data;
        if (!players.some(p => p.name === gameState.playerName)) {
             players.push({ name: gameState.playerName, lifetimeSouls: gameState.lifetimeSouls, ascensions: gameState.ascensions, pvpWins: gameState.pvpWins });
        }
        
        let rankingMetric = 'Souls';
        switch (type) {
            case 'ascensions': players.sort((a,b) => (b.ascensions || 0) - (a.ascensions || 0)); rankingMetric = 'Ascensions'; title.innerText = 'Ranking by Ascensions'; break;
            case 'pvpWins': players.sort((a,b) => (b.pvpWins || 0) - (a.pvpWins || 0)); rankingMetric = 'Wins'; title.innerText = 'Ranking by PvP Wins'; break;
            default: players.sort((a,b) => (b.lifetimeSouls || 0) - (a.lifetimeSouls || 0)); rankingMetric = 'Souls'; title.innerText = 'Ranking by Total Souls'; break;
        }

        list.innerHTML = '';
        players.slice(0, 10).forEach((player, index) => {
            const li = document.createElement('li');
            let value = (type === 'ascensions') ? (player.ascensions || 0) : (type === 'pvpWins') ? (player.pvpWins || 0) : formatNumber(player.lifetimeSouls || 0);
            li.innerHTML = `<span>#${index + 1} ${player.name}</span> <span>${value} ${rankingMetric}</span>`;
            if (player.name === gameState.playerName) li.style.cssText = 'color: var(--primary-color); font-weight: bold; border-color: var(--primary-color);';
            list.appendChild(li);
        });
    } catch (e) {
        list.innerHTML = `<li>Error summoning spirits. The abyss is unstable.</li>`;
        console.error("Leaderboard Error:", e);
    }
}

async function fetchPvpTargets() {
    const targetList = document.getElementById('pvp-target-list');
    if (!targetList || !supabaseClient || SUPABASE_URL.includes("YOUR_SUPABASE")) {
        targetList.innerHTML = `<li>PvP Database not configured. See Step 1 in the tutorial.</li>`;
        return;
    }
    targetList.innerHTML = '<li><em>Scouring the abyss for rivals...</em></li>';
    try {
        const { data, error } = await supabaseClient
            .from('players')
            .select('*')
            .neq('name', gameState.playerName)
            .gte('lifetimeSouls', gameState.lifetimeSouls * 0.25) // Widen the search range
            .lte('lifetimeSouls', gameState.lifetimeSouls * 4);
        if (error) throw error;
        
        const potentialTargets = data.sort(() => 0.5 - Math.random()).slice(0, 5);
        window.potentialTargetsData = data; // Store full data for raidPlayer to use
        
        targetList.innerHTML = '';
        if (potentialTargets.length === 0) {
            targetList.innerHTML = `<li>No suitable targets found in your soul range. Grow stronger or weaker.</li>`;
            return;
        }
        potentialTargets.forEach(player => {
            const li = document.createElement('li');
            li.innerHTML = `<span>${player.name} (Souls: ${formatNumber(player.lifetimeSouls)})</span> <button class="upgrade-btn" style="width: 100px;" onclick="raidPlayer('${player.name}')">Raid</button>`;
            targetList.appendChild(li);
        });
    } catch(e) {
        targetList.innerHTML = `<li>Error finding targets. The abyss resists your scrying.</li>`;
        console.error("PvP Target Error:", e);
    }
}

function raidPlayer(targetName) {
    if (Date.now() < gameState.raidCooldownEnd) {
        alert("Your raiding parties are exhausted. Wait for the cooldown.");
        return;
    }
    if (!window.potentialTargetsData) {
        alert("Target data has expired! Please find new opponents first.");
        return;
    }
    const defender = window.potentialTargetsData.find(p => p.name === targetName);
    if (!defender) {
        alert("Target has vanished!");
        return;
    }

    // --- SETUP DUEL STATE ---
    duelState = {
        active: true,
        timer: 15,
        opponent: defender,
        playerMaxHealth: 100,
        playerCurrentHealth: 100,
        opponentMaxHealth: 100,
        opponentCurrentHealth: 100,
        opponentAttackInterval: Math.max(200, 1000 - Math.log10(defender.lifetimeSouls || 1) * 50),
        lastOpponentAttack: Date.now()
    };

    // Apply item bonuses
    const helmId = gameState.equipped.helm;
    if (helmId && items[helmId]) {
        const bonus = items[helmId].bonus;
        if (bonus.type === 'pvp_defense') duelState.opponentAttackInterval *= (1 / bonus.value); 
        if (bonus.type === 'pvp_offense') duelState.playerDamageMultiplier = bonus.value;
        if (bonus.type === 'pvp_headstart') duelState.playerDamageImmuneUntil = Date.now() + (bonus.value * 1000);
    }

    // --- SHOW UI & START LOOPS (THIS IS THE FIX) ---
    document.getElementById('duel-overlay').style.display = 'flex';
    document.getElementById('duel-container').innerHTML = `
        <h2 id="duel-title">Channeling Duel!</h2>
        <div class="duel-bar-container">
            <div id="opponent-name">VS ${defender.name}</div>
            <div class="health-bar"><div id="opponent-health-fill" class="health-fill"></div></div>
        </div>
        <div id="duel-arena"><div id="soul-core" onclick="duelClickCore()"></div></div>
        <div class="duel-bar-container">
            <div id="player-duel-name">Your Power</div>
            <div class="health-bar"><div id="player-health-fill" class="health-fill"></div></div>
        </div>
        <div id="duel-timer">15</div>`;
    
        document.getElementById('duel-overlay').style.display = 'flex';
    document.getElementById('opponent-name').innerText = `VS ${defender.name}`;
    updateDuelUI();

    // START THE TIMERS - THIS IS THE FIX
    duelState.gameInterval = setInterval(duelGameLoop, 1000 / 60); // Run at 60fps
    duelState.weakPointInterval = setInterval(spawnWeakPoint, 1800);
} // <--- This is the closing brace

function renderPvpLog() {
    const logList = document.getElementById('pvp-log-list');
    if (!logList) return;
    logList.innerHTML = '';
    if (!gameState.attackLog || gameState.attackLog.length === 0) {
        logList.innerHTML = '<li>Your log is clear.</li>';
        return;
    }
    [...gameState.attackLog].reverse().slice(0, 10).forEach(entry => {
        const li = document.createElement('li');
        li.innerHTML = entry.message;
        li.style.color = entry.type === 'win' ? 'lime' : 'var(--primary-color)';
        logList.appendChild(li);
    });
}

function updateRaidCooldownDisplay() {
    const timerEl = document.getElementById('raid-cooldown-timer');
    if (!timerEl) return;
    const now = Date.now();
    if (now < gameState.raidCooldownEnd) {
        const timeLeft = Math.ceil((gameState.raidCooldownEnd - now) / 1000);
        timerEl.innerText = `Raid Cooldown: ${timeLeft}s`;
    } else {
        timerEl.innerText = 'Raid Ready!';
    }
}

function duelClickCore() {
    if (!duelState.active) return;
    // FIXED: Damage is a small, fixed amount, not based on your huge SPC.
    let damage = 2.5; 
    const helmId = gameState.equipped.helm;
    if (helmId && items[helmId]?.bonus.type === 'pvp_offense') {
        damage *= items[helmId].bonus.value;
    }
    duelState.opponentCurrentHealth -= damage;
    if (duelState.opponentCurrentHealth <= 0) endDuel(true);
    updateDuelUI();
}

function duelClickWeakPoint(event) {
    if (!duelState.active) return;
    // FIXED: Weak point is a critical hit, dealing more fixed damage.
    let damage = 10;
     const helmId = gameState.equipped.helm;
    if (helmId && items[helmId]?.bonus.type === 'pvp_offense') {
        damage *= items[helmId].bonus.value;
    }
    duelState.opponentCurrentHealth -= damage;
    event.target.remove(); // Remove the weak point after clicking
    if (duelState.opponentCurrentHealth <= 0) endDuel(true);
    updateDuelUI();
}

function spawnWeakPoint() {
    if (!duelState.active) return;
    const arena = document.getElementById('duel-arena');
    const weakPoint = document.createElement('div');
    weakPoint.className = 'weak-point';
    weakPoint.onclick = duelClickWeakPoint;
    const angle = Math.random() * 2 * Math.PI;
    const radius = 90;
    const x = Math.cos(angle) * radius + (arena.clientWidth / 2) - 20;
    const y = Math.sin(angle) * radius + (arena.clientHeight / 2) - 20;
    weakPoint.style.left = `${x}px`;
    weakPoint.style.top = `${y}px`;
    arena.appendChild(weakPoint);
    setTimeout(() => weakPoint.remove(), 1700);
}

function duelGameLoop() {
    if (!duelState.active) return;
    const now = Date.now();
    
    // Opponent attacks on their interval
    if (now > duelState.lastOpponentAttack + duelState.opponentAttackInterval) {
        let opponentDamage = 10;
        const helmId = gameState.equipped.helm;
        if (helmId && items[helmId]?.bonus.type === 'pvp_defense') {
            opponentDamage *= items[helmId].bonus.value;
        }
        duelState.playerCurrentHealth -= opponentDamage;
        duelState.lastOpponentAttack = now;
        
        const core = document.getElementById('soul-core');
        if(core) {
            core.classList.remove('opponent-attack');
            void core.offsetWidth; // Trigger reflow
            core.classList.add('opponent-attack');
        }
    }

    duelState.timer -= (1 / 60);
    if (duelState.playerCurrentHealth <= 0) {
        endDuel(false);
    } else if (duelState.timer <= 0) {
        endDuel(duelState.playerCurrentHealth > duelState.opponentCurrentHealth);
    }
    updateDuelUI();
}

function updateDuelUI() {
    if (!duelState.active) return;
    const opponentHealthPercent = Math.max(0, (duelState.opponentCurrentHealth / duelState.opponentMaxHealth) * 100);
    document.getElementById('opponent-health-fill').style.width = `${opponentHealthPercent}%`;
    const playerHealthPercent = Math.max(0, (duelState.playerCurrentHealth / duelState.playerMaxHealth) * 100);
    document.getElementById('player-health-fill').style.width = `${playerHealthPercent}%`;
    document.getElementById('duel-timer').innerText = Math.ceil(duelState.timer);
}

function endDuel(playerWon) {
    if (!duelState.active) return; // Prevent this from running multiple times
    clearInterval(duelState.gameInterval);
    clearInterval(duelState.weakPointInterval);
    duelState.active = false;
    
    const defender = duelState.opponent;
    const duelContainer = document.getElementById('duel-container');

    if (playerWon) {
        const soulsStolen = Math.floor((defender.lifetimeSouls || 0) * 0.05) + 100;
        gameState.souls += soulsStolen;
        gameState.pvpWins++;
        gameState.attackLog.push({ type: 'win', message: `You crushed ${defender.name} and claimed ${formatNumber(soulsStolen)} souls.` });
        duelContainer.innerHTML = `<div id="duel-result-screen">
            <h2 style="color: lime;">VICTORY</h2>
            <p>You have overwhelmed ${defender.name}!</p>
            <p>Stolen: <span class="cost-souls">${formatNumber(soulsStolen)}</span> souls.</p>
        </div>`;
    } else {
        const soulsLost = Math.floor(gameState.souls * 0.05);
        gameState.souls = Math.max(0, gameState.souls - soulsLost);
        gameState.pvpLosses++;
        gameState.attackLog.push({ type: 'loss', message: `You were defeated by ${defender.name} and lost ${formatNumber(soulsLost)} souls.` });
        duelContainer.innerHTML = `<div id="duel-result-screen">
            <h2 style="color: red;">DEFEAT</h2>
            <p>Your channeling was disrupted!</p>
            <p>Lost: <span class="cost-souls">${formatNumber(soulsLost)}</span> souls.</p>
        </div>`;
    }

    // Wait 4 seconds before closing the duel screen
    setTimeout(() => {
        document.getElementById('duel-overlay').style.display = 'none';
        gameState.raidCooldownEnd = Date.now() + 60000; // 1 minute cooldown
        renderAll();
        saveGame();
    }, 4000);
}
// =================================================================
// ANTI-CHEAT & VISUALS
// =================================================================
function runAntiCheatChecks() { const now = Date.now(); checkClickSpam(now); checkClickRhythm(now); }
function checkClickSpam(now) { antiCheatState.clickTimestamps.push(now); const oneSecondAgo = now - 1000; antiCheatState.clickTimestamps = antiCheatState.clickTimestamps.filter(t => t >= oneSecondAgo); if (antiCheatState.clickTimestamps.length > 25) { console.warn("Anti-Cheat Triggered: High CPS"); punishPlayer(); } }
function checkClickRhythm(now) { if (antiCheatState.clickTimestamps.length < 2) return; const lastClickTime = antiCheatState.clickTimestamps[antiCheatState.clickTimestamps.length - 2]; const interval = now - lastClickTime; antiCheatState.clickIntervals.push(interval); if (antiCheatState.clickIntervals.length > 10) { antiCheatState.clickIntervals.shift(); const stdDev = calculateStandardDeviation(antiCheatState.clickIntervals); if (stdDev < 3) { console.warn(`Anti-Cheat Triggered: Low Rhythm Deviation (${stdDev})`); punishPlayer(); } } }
function punishPlayer() { if (antiCheatState.isLockedOut) return; antiCheatState.isLockedOut = true; antiCheatState.punishmentLevel++; const lockoutTime = 5000 * antiCheatState.punishmentLevel; alert(`An unstable connection to the abyss has been detected. Harvesting disabled for ${lockoutTime / 1000} seconds.`); const btn = document.querySelector('.action-btn'); const originalText = btn.innerText; btn.innerText = "CONNECTION UNSTABLE"; btn.disabled = true; setTimeout(() => { antiCheatState.isLockedOut = false; btn.innerText = originalText; btn.disabled = false; antiCheatState.clickTimestamps = []; antiCheatState.clickIntervals = []; }, lockoutTime); }
function calculateStandardDeviation(array) { if (!array.length) return 0; const n = array.length; const mean = array.reduce((a, b) => a + b) / n; const variance = array.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / n; return Math.sqrt(variance); }

// =================================================================
// ABYSSAL RIFT VISUALIZER
// =================================================================
let riftCtx, riftParticles;

function initRift() {
    const canvas = document.getElementById('rift-canvas');
    const btn = document.querySelector('.action-btn');
    if (!canvas || !btn) return;

    // Make the canvas slightly larger than the button
    canvas.width = btn.offsetWidth + 100;
    canvas.height = btn.offsetHeight + 100;

    riftCtx = canvas.getContext('2d');
    riftParticles = [];
    for (let i = 0; i < 50; i++) {
        riftParticles.push({
            x: canvas.width / 2,
            y: canvas.height / 2,
            size: Math.random() * 2 + 1,
            speedX: (Math.random() - 0.5) * 2,
            speedY: (Math.random() - 0.5) * 2,
            color: `rgba(179, 33, 33, ${Math.random() * 0.5 + 0.2})`,
            life: Math.random() * 200, // Start at a random point in their life
            maxLife: Math.random() * 100 + 100,
        });
    }
    drawRift(); // Start the animation loop
}

function drawRift() {
    if (!riftCtx) return;

    const canvas = riftCtx.canvas;
    riftCtx.clearRect(0, 0, canvas.width, canvas.height);

    riftParticles.forEach(p => {
        p.x += p.speedX;
        p.y += p.speedY;
        p.life++;

        // Reset particle when it dies or goes off-screen
        if (p.life >= p.maxLife || p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) {
            p.x = canvas.width / 2;
            p.y = canvas.height / 2;
            p.life = 0;
            // Speed is influenced by Souls Per Click, making the rift more violent as you get stronger
            const power = Math.min(10, 1 + Math.log10(gameState.stats.spc || 1));
            p.speedX = (Math.random() - 0.5) * power;
            p.speedY = (Math.random() - 0.5) * power;
        }

        // Fade in and out over lifetime
        const intensity = Math.sin(p.life / p.maxLife * Math.PI);
        
        riftCtx.beginPath();
        riftCtx.fillStyle = p.color;
        riftCtx.globalAlpha = intensity * 0.8; // Make it slightly transparent
        riftCtx.arc(p.x, p.y, p.size * intensity, 0, Math.PI * 2);
        riftCtx.fill();
    });

    requestAnimationFrame(drawRift);
}
</script>
</body>
</html>
