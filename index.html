<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Soul Collector - Abyssal Ascension</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&family=Sorts+Mill+Goudy&display=swap');
        :root {
            --background-color: #0a0908; --dark-panel-color: #1c1a19; --light-panel-color: #2a2726;
            --border-color: #4d4d4d; --primary-color: #b32121; --primary-glow: rgba(179, 33, 33, 0.7);
            --accent-color: #d4af37; --accent-glow: rgba(212, 175, 55, 0.5);
            --prestige-color: #e8e8e8; --prestige-glow: rgba(232, 232, 232, 0.5);
            --secondary-color: #d1cbc1; --dim-color: #8a8174;
            --font-title: 'Cinzel Decorative', serif; --font-body: 'Sorts Mill Goudy', serif;
            --font-size-base: 16px; --font-size-large: 1.2rem; --font-size-xl: 1.8rem; --font-size-xxl: 2.5rem;
            --border-radius: 2px; --transition-speed: 0.3s;
        }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.98); } to { opacity: 1; transform: scale(1); } }
        @keyframes soulThump { 0% { transform: scale(1); } 50% { transform: scale(0.97); } 100% { transform: scale(1); } }
        .soul-particle { position: absolute; width: 5px; height: 15px; background: var(--primary-color); border: 1px solid black; box-shadow: 0 0 10px var(--primary-glow); pointer-events: none; opacity: 1; animation: fly-out 0.8s ease-out forwards; }
        @keyframes fly-out { from { transform: translate(0, 0) scale(1) rotate(0deg); opacity: 1; } to { transform: translate(var(--x), var(--y)) scale(0) rotate(360deg); opacity: 0; } }
        body { background-color: var(--background-color); box-shadow: inset 0 0 150px #000; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEWFhYWDg4N3d3dtbW17e3t1dXWBgYGHh4d5eXlzc3OLi4ubm5uVlZWPj4+NjY19fX2JiYqUlJSbm5rR0dGSkpJZWVl4eHhfX1/Kysqztba6urqloqPy8/P19fX7+/sbwLSUAAAANElEQVR42mNgBAINDDxdgIvNlBPEyYPAyMDM0M0w9D8cmBjg8D8yMDBdBSMDBgABo4MBgABhIUgAAAAASUVORK5CYII='); color: var(--secondary-color); font-family: var(--font-body); font-size: var(--font-size-base); text-align: center; padding: 15px; margin: 0; user-select: none; }
        #game-container { max-width: 950px; margin: 20px auto; border: 3px solid #111; border-top: 3px solid #333; border-bottom: 3px solid #333; background-color: var(--dark-panel-color); background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyBAMAAADsEZWCAAAAFVBMVEUuLi4nJycnJycrKysrKyspKSkpKSkQCBURAAAAB3RSTlMAoAr2p/Th2c9jAAAAh0lEQVQ4y2NgGAWjgEVBIIsFWBIMdkyY2DBRYGPB+MvAxIaJCTMdxgATRIYN+2A0wEjEASZ0mHw3g8jEASZ0GHo3g8jEASZ0mHw3g8jEASZ0GHo3g8jEASZ0mHw3g8jEASZ0GHo3g8jEASZ0mHw3g8jEASZ0GAYBAB2wAkeI31rqAAAAAElFTSuQmCC'); box-shadow: 0 0 50px rgba(0,0,0,0.9); overflow: hidden; }
        nav { display: flex; background-color: #000; border-bottom: 3px solid #111; flex-wrap: wrap; }
        nav button { flex-grow: 1; padding: 18px 5px; font-family: var(--font-title); background: var(--dark-panel-color); border: none; border-right: 1px solid #000; color: var(--dim-color); font-size: var(--font-size-large); cursor: pointer; transition: all var(--transition-speed); }
        nav button:last-child { border-right: none; }
        nav button:hover { background-color: var(--light-panel-color); color: var(--accent-color); }
        nav button.active { background: linear-gradient(to top, var(--primary-color), #c83131); color: white; text-shadow: 0 0 8px black; font-size: 1.25rem; }
        .screen { padding: 25px; display: none; }
        .screen.active { display: block; animation: fadeIn 0.7s; }
        #player-stats { display: flex; justify-content: space-around; flex-wrap: wrap; background: #050505; padding: 15px; border-bottom: 3px solid #111; font-family: var(--font-title); font-size: var(--font-size-large); }
        #player-stats div { margin: 5px 15px; } #player-stats span { font-weight: bold; }
        #souls-display, #essence-display, #shards-display { text-shadow: 0 0 10px currentColor; }
        #essence-display { color: var(--accent-color); } #shards-display { color: var(--prestige-color); }
        h1, h2, h3 { font-family: var(--font-title); color: var(--primary-color); text-shadow: 1px 1px 0 #000, 3px 3px 5px #000, 0 0 15px var(--primary-glow); text-transform: uppercase; letter-spacing: 3px; }
        h1 { font-size: var(--font-size-xxl); } h2 { font-size: var(--font-size-xl); margin-bottom: 0; }
        h3 { color: var(--secondary-color); text-shadow: 1px 1px 2px #000; letter-spacing: 1px; }
        .screen p { font-size: 1.1rem; }
        #rift-container { position: relative; margin: 25px auto; width: 300px; height: 120px; }
        #rift-canvas { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1; pointer-events: none; opacity: 0.7; }
        button.action-btn { padding: 25px 50px; font-size: var(--font-size-xl); font-family: var(--font-title); background: linear-gradient(145deg, #c02323, var(--primary-color)); color: white; border: 2px solid #000; border-bottom: 4px solid #000; border-right: 4px solid #000; box-shadow: inset 0 0 15px rgba(0,0,0,0.7); cursor: pointer; transition: all 0.1s ease-out; text-transform: uppercase; display: block; position: relative; z-index: 2; margin: 0 auto; }
        button.action-btn:hover { background: #d03333; }
        button.action-btn:active { transform: translate(2px, 2px); border-bottom-width: 2px; border-right-width: 2px; }
        .action-btn.thump-animation { animation: soulThump 0.2s ease-in-out; }
        .upgrade-section, .minion-grid, .artifact-grid { display: flex; justify-content: center; gap: 20px; margin-top: 30px; flex-wrap: wrap; }
        button.upgrade-btn { padding: 20px; background: var(--light-panel-color); color: var(--secondary-color); cursor: pointer; border: 2px solid var(--border-color); width: 260px; text-align: left; border-radius: var(--border-radius); transition: all var(--transition-speed); box-shadow: inset 0 0 10px rgba(0,0,0,0.5); line-height: 1.5; }
        button.upgrade-btn:hover:not(:disabled) { border-color: var(--accent-color); background: #33302e; transform: translateY(-2px); box-shadow: inset 0 0 5px rgba(0,0,0,0.5), 0 2px 10px var(--accent-glow); }
        button.upgrade-btn.owned, button:disabled { background-color: var(--dark-panel-color); color: #666; cursor: not-allowed; border-color: #333; filter: grayscale(80%); }
        .btn-title { font-family: var(--font-title); font-size: 1.4rem; color: white; letter-spacing: 1px; margin-bottom: 5px; }
        .btn-level { color: var(--dim-color); font-size: 1rem; font-style: italic; }
        .cost { font-size: 1.1rem; margin-top: 10px; display: block; }
        .cost-souls { color: var(--prestige-color); font-weight: bold; } .cost-essence { color: var(--accent-color); font-weight: bold; } .cost-shards { color: var(--prestige-color); font-weight: bold; }
        hr { border: 0; height: 2px; background: #000; margin: 30px 0; }
        #map-grid, #leaderboard-list, #pvp-target-list, #pvp-log-list { list-style: none; padding: 0; text-align: left; margin: 20px auto; max-width: 650px; }
        #map-grid li, #leaderboard-list li, #pvp-target-list li, #pvp-log-list li { background: var(--light-panel-color); border: 2px solid var(--border-color); padding: 20px; margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center; border-radius: var(--border-radius); font-size: 1.1rem; }
        #map-grid li.active-world { border-color: var(--primary-color); background: var(--dark-panel-color); }
        #leaderboard-list li:first-child { border-color: gold; box-shadow: 0 0 15px rgba(255,215,0,0.5); }
        #ascension-screen { border: 3px double var(--primary-color); background-color: rgba(160, 28, 28, 0.1); padding: 30px; }
        #ascension-screen h2 { color: var(--primary-color); } .ascend-btn { background: var(--prestige-color); color: #000; font-family: var(--font-title); font-weight: bold; font-size: 1.3rem; border: 2px solid #000; }
        #profile-setup { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; justify-content: center; align-items: center; z-index: 100; backdrop-filter: blur(5px); }
        #profile-setup div { padding: 40px; background: var(--dark-panel-color); border: 2px solid #000; box-shadow: 0 0 40px rgba(0,0,0,0.7); }
        #profile-setup input { padding: 10px; font-size: 1.1rem; background: #111; border: 1px solid #333; color: white; margin-right: 10px; border-radius: 0; font-family: var(--font-body); }
        #profile-setup input:focus { border-color: var(--primary-color); outline: none; }
        [data-tooltip] { position: relative; }
        [data-tooltip]::after { content: attr(data-tooltip); position: absolute; left: 50%; bottom: 110%; transform: translateX(-50%); background: #000; border: 1px solid var(--border-color); color: var(--secondary-color); padding: 10px 15px; border-radius: var(--border-radius); font-size: 1rem; font-family: var(--font-body); pointer-events: none; opacity: 0; transition: opacity var(--transition-speed); width: max-content; max-width: 320px; z-index: 10; line-height: 1.4; }
        [data-tooltip]:hover::after { opacity: 1; }
        #duel-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; justify-content: center; align-items: center; z-index: 200; backdrop-filter: blur(5px); }
        #duel-container { width: 90%; max-width: 600px; text-align: center; color: white; }
        #duel-title { font-size: 3rem; color: var(--primary-color); text-shadow: 0 0 15px var(--primary-glow); }
        .duel-bar-container { margin: 15px 0; font-family: var(--font-title); font-size: 1.2rem; }
        .health-bar { width: 100%; height: 30px; background-color: #333; border: 2px solid #111; margin-top: 5px; padding: 2px; }
        .health-fill { height: 100%; width: 100%; background: linear-gradient(to right, var(--primary-color), #d03333); transition: width 0.2s linear; }
        #player-health-fill { background: linear-gradient(to right, #00e5ff, #00a1b8); }
        #duel-arena { position: relative; width: 250px; height: 250px; margin: 40px auto; border: 2px solid var(--border-color); border-radius: 50%; background: radial-gradient(circle, #222, #000); }
        #soul-core { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100px; height: 100px; background-color: var(--primary-color); border-radius: 50%; cursor: pointer; box-shadow: 0 0 20px var(--primary-glow), inset 0 0 15px rgba(0,0,0,0.7); transition: transform 0.1s; }
        #soul-core:active { transform: translate(-50%, -50%) scale(0.9); }
        .weak-point { position: absolute; width: 40px; height: 40px; background-color: var(--accent-color); border-radius: 50%; cursor: pointer; box-shadow: 0 0 15px var(--accent-glow); animation: fadeIn 0.5s; z-index: 210; }
        .weak-point:hover { transform: scale(1.1); }
        #duel-timer { font-size: 2.5rem; font-family: var(--font-title); color: var(--prestige-color); }
        #cache-container { padding: 15px; background: #050505; border-top: 3px solid #111; }
        #abyssal-cache-btn { width: 300px; padding: 10px; font-family: var(--font-title); font-size: 1.5rem; color: white; background: linear-gradient(145deg, #444, #222); border: 2px solid #000; cursor: pointer; transition: all 0.2s; }
        #abyssal-cache-btn:not(:disabled) { background: linear-gradient(145deg, var(--accent-color), #b8860b); text-shadow: 0 0 10px white; animation: pulseCache 2s infinite; }
        @keyframes pulseCache { 0% { transform: scale(1); box-shadow: 0 0 10px transparent; } 50% { transform: scale(1.03); box-shadow: 0 0 20px var(--accent-glow); } 100% { transform: scale(1); box-shadow: 0 0 10px transparent; } }
        #cache-timer-text { font-size: 1rem; font-family: var(--font-body); color: var(--dim-color); }
        #abyssal-cache-btn:not(:disabled) #cache-timer-text { color: white; font-weight: bold; }
        #item-modal-overlay, #lore-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; justify-content: center; align-items: center; z-index: 300; backdrop-filter: blur(5px); }
        #item-modal-content, #lore-modal-content { padding: 30px; background: var(--dark-panel-color); border: 2px solid var(--accent-color); text-align: center; box-shadow: 0 0 30px var(--accent-glow); max-width: 400px; }
        #item-modal-reward { margin: 20px 0; padding: 20px; background: var(--light-panel-color); border: 1px solid var(--border-color); }
        .item-name { font-family: var(--font-title); font-size: 1.5rem; }
        .item-desc { font-family: var(--font-body); font-size: 1rem; color: var(--secondary-color); max-width: 300px; }
    </style>
</head>
<body>
    <div id="duel-overlay" style="display: none;">
        <div id="duel-container">
            <h2 id="duel-title">Channeling Duel!</h2>
            <div class="duel-bar-container">
                <div id="opponent-name">VS SkullMancer</div>
                <div class="health-bar"><div id="opponent-health-fill" class="health-fill"></div></div>
            </div>
            <div id="duel-arena">
                <div id="soul-core" onclick="duelClickCore()"></div>
            </div>
            <div class="duel-bar-container">
                <div id="player-duel-name">Your Power</div>
                <div class="health-bar"><div id="player-health-fill" class="health-fill"></div></div>
            </div>
            <div id="duel-timer">15</div>
        </div>
    </div>
    <div id="profile-setup" style="display: none;">
        <div>
            <h2>Create Your Profile</h2>
            <p>Enter your name, Soul Collector.</p>
            <input type="text" id="playerNameInput" placeholder="BoneLordX" maxlength="15">
            <button class="upgrade-btn" onclick="createProfile()">Begin the Harvest</button>
        </div>
    </div>
    <div id="game-container" style="display: none;">
        <header id="player-stats">
            <div>Player: <span id="playerName-display"></span></div>
            <div>Souls: <span id="souls-display">0</span></div>
            <div><span style="color:var(--accent-color)">Dark Essence:</span> <span id="essence-display">0</span></div>
            <div><span style="color:var(--prestige-color)">Abyssal Shards:</span> <span id="shards-display">0</span></div>
        </header>
        <nav>
            <button onclick="showScreen('altar')" class="active">Altar</button>
            <button onclick="showScreen('minions')">Minions</button>
            <button onclick="showScreen('brewery')">Brewery</button>
            <button onclick="showScreen('inventory')">Inventory</button>
            <button onclick="showScreen('artifacts')">Artifacts</button>
            <button onclick="showScreen('rituals')">Rituals</button>
            <button onclick="showScreen('map')">Worlds</button>
            <button onclick="showScreen('pvp')">Raids</button>
            <button onclick="showScreen('leaderboard')">Leaderboard</button>
            <button onclick="showScreen('ascension')">ASCEND</button>
        </nav>
        <main>
            <div id="altar-screen" class="screen active">
                <h1 id="world-title">üëª Nether Plains üëª</h1>
                <p>Souls Per Second: <span id="sps-display">0</span> | Souls Per Click: <span id="spc-display">1</span></p>
                <div id="rift-container">
                    <canvas id="rift-canvas" width="400" height="200"></canvas>
                    <button class="action-btn" onclick="harvestSoul()">Harvest Soul</button>
                </div>
                <div class="upgrade-section">
                    <button class="upgrade-btn" id="clickUpgradeBtn" onclick="buyUpgrade('click')">
                        <span class="btn-title">Empower Harvest</span><br>
                        <span class="btn-level">Lvl: <span id="clickLevel">1</span></span><br>
                        <span class="cost">Cost: <span id="clickCost" class="cost-souls">10</span></span>
                    </button>
                    <button class="upgrade-btn" id="sacrificeBtn" onclick="buyUpgrade('sacrifice')">
                        <span class="btn-title">Sacrifice Souls</span><br>
                        <span>Gain 1 Dark Essence</span><br>
                        <span class="cost">Cost: <span id="sacrificeCost" class="cost-souls">1000</span></span>
                    </button>                    
                    <button class="upgrade-btn" id="resonanceUpgradeBtn" onclick="buyUpgrade('resonance')" data-tooltip="This is a permanent upgrade that persists through Ascension. It's one of the most important upgrades for long-term growth!">
                        <span class="btn-title">Soul Resonance</span><br>
                        <span class="btn-level">Lvl: <span id="resonanceLevel">0</span></span><br>
                        <span class="cost">Gain +5% Shards on Ascend per level.</span><br>
                        <span class="cost">Cost: <span id="resonanceCost" class="cost-essence">5</span></span>
                    </button>
                </div>
            </div>
            <div id="brewery-screen" class="screen">
                <h2>The Alchemical Brewery</h2><p>Concoct powerful, single-use potions for potent effects.</p>
                <h3>Your Inventory</h3><div id="potion-inventory" class="minion-grid"></div><hr>
                <h3>Available Recipes</h3><div id="potion-recipe-grid" class="minion-grid"></div>
            </div>
            <div id="inventory-screen" class="screen">
                <h2>Inventory & Equipment</h2><p>Equip items from your Abyssal Caches to gain their powerful bonuses.</p>
                <h3>Equipped Items</h3><div id="equipped-items-grid" class="minion-grid"></div><hr>
                <h3>Stored Items</h3><div id="inventory-items-grid" class="minion-grid"></div>
            </div>
            <div id="minions-screen" class="screen">
                <h2>üòà Demonic Minions üòà</h2><p>Enslave creatures to passively harvest souls for you.</p>
                <div id="minion-grid" class="minion-grid"></div>
            </div>
            <div id="artifacts-screen" class="screen">
                <h2>üíé Abyssal Artifacts üíé</h2><p>Spend Dark Essence on powerful, permanent items.</p>
                <div id="artifact-grid" class="artifact-grid"></div>
            </div>
            <div id="rituals-screen" class="screen">
                <h2>üîÆ Dark Rituals üîÆ</h2><p>Perform costly rituals for immense, temporary power.</p>
                <div id="ritual-grid" class="ritual-grid"></div>
            </div>
            <div id="map-screen" class="screen">
                <h2>üåê Map of the Underworlds</h2><ul id="map-grid"></ul>
            </div>
            <div id="pvp-screen" class="screen">
                <h2>üî• PvP Soul Raids üî•</h2><p>Raid the databases of other players for souls and glory.</p>
                <div id="pvp-actions"><button class="upgrade-btn" onclick="fetchPvpTargets()">Find New Opponents</button>
                <div id="raid-cooldown-timer"></div></div>
                <h3>Potential Targets</h3><ul id="pvp-target-list" class="leaderboard-list"></ul><hr>
                <h3>Your Raid Log</h3><ul id="pvp-log-list" class="leaderboard-list"></ul>
            </div>
            <div id="leaderboard-screen" class="screen">
                <h2>üèÜ Leaderboards üèÜ</h2>
                <div class="upgrade-section">
                    <button class="upgrade-btn" onclick="fetchLeaderboard('lifetimeSouls')">By Total Souls</button>
                    <button class="upgrade-btn" onclick="fetchLeaderboard('ascensions')">By Ascensions</button>
                    <button class="upgrade-btn" onclick="fetchLeaderboard('pvpWins')">By PvP Wins</button>
                </div>
                <h3 id="leaderboard-title">Ranking by Total Souls</h3><ul id="leaderboard-list"></ul>
            </div>
            <div id="ascension-screen" class="screen">
                <h2>‚ú® Shatter the Soul Core ‚ú®</h2>
                <p>Ascension is the key to true power. Reset your current progress (souls, minions, upgrades, worlds) to gain <span class="cost-shards">Abyssal Shards</span> based on your total souls harvested this run.</p>
                <p>Shards provide a MASSIVE permanent boost to all soul gains.</p>
                <p>Requirement: Reach the 'Void Threshold' world to unlock.</p><hr>
                <h3>You will gain: <span id="shardsOnAscend" class="cost-shards">0</span> Abyssal Shards</h3>
                <button class="upgrade-btn ascend-btn" id="ascendBtn" onclick="performAscension()" disabled>ASCEND</button>
            </div>
            <div id="cache-container">
                <button id="abyssal-cache-btn" onclick="openAbyssalCache()" disabled>
                    <div id="cache-ready-text">ABYSSAL CACHE</div><div id="cache-timer-text">Sealed...</div>
                </button>
            </div>
            <div id="item-modal-overlay" style="display: none;">
                <div id="item-modal-content">
                    <h2 id="item-modal-title">Cache Opened!</h2>
                    <div id="item-modal-reward"></div>
                    <button class="upgrade-btn" onclick="closeItemModal()">Claim</button>
                </div>
            </div>
            <div id="lore-modal-overlay" style="display: none;">
                 <div id="lore-modal-content">
                    <h2 id="lore-modal-title"></h2>
                    <p id="lore-modal-text"></p>
                    <button class="upgrade-btn" onclick="closeLoreModal()">Continue</button>
                </div>
            </div>
        </main>
    </div>

<script>
// =================================================================
// PVP DATABASE & AUDIO SETUP
// =================================================================
// --- PASTE YOUR SUPABASE URL AND ANON KEY HERE ---
const SUPABASE_URL = 'https://gqlpebvyiobwdyiezxma.supabase.co'; 
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdxbHBlYnZ5aW9id2R5aWV6eG1hIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM4ODc5NDksImV4cCI6MjA2OTQ2Mzk0OX0.t2ezVurCrC1uOsdKaPJSddQmdeQnhPlFlv9HDTSftHQ';
// -------------------------------------------------

let supabase;
if (SUPABASE_URL !== 'YOUR_SUPABASE_URL' && SUPABASE_URL) {
    supabase = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
}
let playerBinId = null; // We will use this to store the player's unique name

const audio = {
    bgm: new Audio(""),
    click: new Audio(""),
    harvest: new Audio(""),
    ascend: new Audio(""),
};
audio.bgm.loop = true;
audio.bgm.volume = 0.3;

// =================================================================
// GAME DATA
// =================================================================

const numberFormatter = new Intl.NumberFormat('en-US', {
    notation: 'compact',
    compactDisplay: 'short'
});

function formatNumber(num) {
    if (num < 100000) {
        return Math.floor(num).toLocaleString();
    }
    return numberFormatter.format(num);
}

const minions = {
    imp: { name: "Imp", baseSps: 0.1, cost: 25, multiplier: 1.15, requiredWorld: 'nether_plains' },
    ghoul: { name: "Ghoul", baseSps: 0.5, cost: 150, multiplier: 1.16, requiredWorld: 'nether_plains' },
    demon: { name: "Lesser Demon", baseSps: 2, cost: 1000, multiplier: 1.18, requiredWorld: 'nether_plains' },
    ash_golem: { name: "Ash Golem", baseSps: 15, cost: 50000, multiplier: 1.20, requiredWorld: 'ashen_wastes' },
    cinder_wraith: { name: "Cinder Wraith", baseSps: 80, cost: 3e5, multiplier: 1.21, requiredWorld: 'ashen_wastes' },
    abyssal_stalker: { name: "Abyssal Stalker", baseSps: 400, cost: 1.5e6, multiplier: 1.22, requiredWorld: 'stygian_depths', bonus: { type: 'sps_to_spc', value: 0.0001 } },
    river_hydra: { name: "River Hydra", baseSps: 2200, cost: 8e6, multiplier: 1.23, requiredWorld: 'stygian_depths' },
    hellhound: { name: "Hellhound", baseSps: 1.2e4, cost: 4e7, multiplier: 1.24, requiredWorld: 'burning_hells' },
    balrog: { name: "Balrog", baseSps: 6e4, cost: 2.5e8, multiplier: 1.25, requiredWorld: 'burning_hells' },
    pit_lord: { name: "Pit Lord", baseSps: 3e5, cost: 1.5e9, multiplier: 1.26, requiredWorld: 'burning_hells' },
    frost_lich: { name: "Frost Lich", baseSps: 2e6, cost: 8e9, multiplier: 1.28, requiredWorld: 'frozen_abyss' },
    icefiend: { name: "Icefiend", baseSps: 1.1e7, cost: 5e10, multiplier: 1.29, requiredWorld: 'frozen_abyss' },
    glacial_titan: { name: "Glacial Titan", baseSps: 6e7, cost: 3e11, multiplier: 1.30, requiredWorld: 'frozen_abyss', bonus: { type: 'global_sps_multiplier_per_level', value: 0.001 } },
    fallen_angel: { name: "Fallen Angel", baseSps: 4e8, cost: 2e12, multiplier: 1.32, requiredWorld: 'celestial_ruins' },
    corrupted_cherub: { name: "Corrupted Cherub", baseSps: 2.5e9, cost: 1.2e13, multiplier: 1.33, requiredWorld: 'celestial_ruins' },
    void_spawn: { name: "Void Spawn", baseSps: 1.5e10, cost: 7e13, multiplier: 1.35, requiredWorld: 'void_threshold' },
    shoggoth: { name: "Shoggoth", baseSps: 9e10, cost: 4e14, multiplier: 1.36, requiredWorld: 'void_threshold' },
    reality_warper: { name: "Reality Warper", baseSps: 6e12, cost: 2e16, multiplier: 1.38, requiredWorld: 'singularity' },
    echo_of_nothing: { name: "Echo of Nothing", baseSps: 4e13, cost: 1e17, multiplier: 1.40, requiredWorld: 'singularity', bonus: { type: 'shards_from_ascension_multiplier_per_level', value: 0.002 } },
    spacetime_ghast: { name: "Spacetime Ghast", baseSps: 3e15, cost: 5e19, multiplier: 1.42, requiredWorld: 'event_horizon' },
    causal_predator: { name: "Causal Predator", baseSps: 2e16, cost: 3e20, multiplier: 1.44, requiredWorld: 'event_horizon', bonus: { type: 'essence_multiplier_per_level', value: 0.005 } },
    nebulous_entity: { name: "Nebulous Entity", baseSps: 1e18, cost: 2e22, multiplier: 1.46, requiredWorld: 'genesis' },
    creator_wisp: { name: "Creator Wisp", baseSps: 8e18, cost: 1e23, multiplier: 1.48, requiredWorld: 'genesis' },
    god_eater: { name: "God Eater", baseSps: 5e22, cost: 5e26, multiplier: 1.50, requiredWorld: 'pantheon_of_ashes' },
    deific_remnant: { name: "Deific Remnant", baseSps: 4e23, cost: 3e27, multiplier: 1.52, requiredWorld: 'pantheon_of_ashes', bonus: { type: 'resonance_effectiveness_per_level', value: 0.01 } },
    time_leech: { name: "Time Leech", baseSps: 2e28, cost: 1e32, multiplier: 1.55, requiredWorld: 'chronos_fault', bonus: { type: 'ritual_cooldown_reducer_per_level', value: 0.001 } },
    eon_devourer: { name: "Eon Devourer", baseSps: 1.5e29, cost: 8e32, multiplier: 1.58, requiredWorld: 'chronos_fault' },
    alpha_omega: { name: "Alpha & Omega", baseSps: 1e35, cost: 1e39, multiplier: 1.65, requiredWorld: 'omega_point', bonus: { type: 'ascension_shard_bonus_per_level', value: 0.005 } },
};

const artifacts = {
    shard_of_avarice: { name: "Shard of Avarice", desc: "Your manual harvests are 100% more effective.", cost: 1, requiredWorld: 'nether_plains', bonus: { type: 'spc_multiplier', value: 2 } },
    demonic_pact: { name: "Demonic Pact", desc: "All minions are 25% more effective.", cost: 2, requiredWorld: 'nether_plains', bonus: { type: 'sps_multiplier', value: 1.25 } },
    unholy_effigy: { name: "Unholy Effigy", desc: "Reduces the cost of all minions by 5%.", cost: 3, requiredWorld: 'nether_plains', bonus: { type: 'minion_cost_reducer', value: 0.95 } },
    brazier_of_cinders: { name: "Brazier of Cinders", desc: "Ash Golems and Cinder Wraiths produce 100% more souls.", cost: 8, requiredWorld: 'ashen_wastes', bonus: { type: 'minion_specific_multiplier', target: ['ash_golem', 'cinder_wraith'], value: 2 } },
    ember_locket: { name: "Ember Locket", desc: "Empower Harvest upgrade is 10% cheaper.", cost: 12, requiredWorld: 'ashen_wastes', bonus: { type: 'upgrade_cost_reducer', target: 'click', value: 0.90 } },
    philosophers_stone: { name: "Philosopher's Stone", desc: "Sacrificing souls yields 20% more Dark Essence.", cost: 15, requiredWorld: 'stygian_depths', bonus: { type: 'essence_multiplier', value: 1.2 } },
    charons_oar: { name: "Charon's Oar", desc: "Each world unlocked increases global soul gain by 5%.", cost: 20, requiredWorld: 'stygian_depths', bonus: { type: 'global_multiplier_per_world', value: 0.05 } },
    crown_of_the_damned: { name: "Crown of the Damned", desc: "Gain 1% more souls for each unique Artifact you own.", cost: 25, requiredWorld: 'burning_hells', bonus: { type: 'global_multiplier_per_artifact', value: 0.01 } },
    hellfire_talisman: { name: "Hellfire Talisman", desc: "Ritual effects last 25% longer.", cost: 40, requiredWorld: 'burning_hells', bonus: { type: 'ritual_duration_multiplier', value: 1.25 } },
    book_of_belial: { name: "Book of Belial", desc: "Rituals cooldown 10% faster.", cost: 50, requiredWorld: 'burning_hells', bonus: { type: 'ritual_cooldown_reducer', value: 0.90 } },
    heart_of_winter: { name: "Heart of Winter", desc: "All 'cold' themed minions are 200% more effective.", cost: 75, requiredWorld: 'frozen_abyss', bonus: { type: 'minion_specific_multiplier', target: ['frost_lich', 'icefiend', 'glacial_titan'], value: 3 } },
    hourglass_of_ages: { name: "Hourglass of Ages", desc: "Gain a 10% bonus to Abyssal Shards when you Ascend.", cost: 100, requiredWorld: 'frozen_abyss', bonus: { type: 'ascension_shard_bonus', value: 0.10 } },
    broken_halo: { name: "Broken Halo", desc: "Fallen Angels and Corrupted Cherubs also boost SPC by 0.01% of their SPS.", cost: 150, requiredWorld: 'celestial_ruins', bonus: { type: 'minion_sps_to_spc', target: ['fallen_angel', 'corrupted_cherub'], value: 0.0001 } },
    scroll_of_heresy: { name: "Scroll of Heresy", desc: "Soul Resonance upgrade is 25% more effective.", cost: 200, requiredWorld: 'celestial_ruins', bonus: { type: 'resonance_bonus_enhancer', value: 0.25 } },
    voidforged_gauntlet: { name: "Voidforged Gauntlet", desc: "Gain 0.5% more souls for each Ascension.", cost: 500, requiredWorld: 'void_threshold', bonus: { type: 'global_multiplier_per_ascension', value: 0.005 } },
    eye_of_the_abyss: { name: "Eye of the Abyss", desc: "The Abyssal Shard soul gain bonus is 10% stronger.", cost: 750, requiredWorld: 'void_threshold', bonus: { type: 'prestige_bonus_enhancer', value: 1.1 } },
    singularity_shard: { name: "Singularity Shard", desc: "All soul gains are multiplied by the number of ascensions you have (min 1).", cost: 2500, requiredWorld: 'singularity', bonus: { type: 'global_multiplier_by_ascensions' } },
    final_testament: { name: "Final Testament", desc: "Doubles the effectiveness of ALL other artifacts.", cost: 10000, requiredWorld: 'singularity', bonus: { type: 'meta_artifact_doubler' } },
    aetheric_lens: { name: "Aetheric Lens", desc: "Dark Essence sacrifices have a 1% chance to yield 100x the essence.", cost: 25000, requiredWorld: 'event_horizon', bonus: { type: 'essence_jackpot_chance', value: 0.01, multiplier: 100 } },
    covenant_of_the_first: { name: "Covenant of the First", desc: "Global soul gain is multiplied by your ascensions SQUARED.", cost: 75000, requiredWorld: 'genesis', bonus: { type: 'global_multiplier_by_ascensions_squared' } },
    paragon_soul: { name: "Paragon Soul", desc: "For every 100 Abyssal Shards, gain a +10% global soul multiplier.", cost: 200000, requiredWorld: 'pantheon_of_ashes', bonus: { type: 'global_multiplier_per_100_shards', value: 0.1 } },
    temporal_anchor: { name: "Temporal Anchor", desc: "After rituals expire, their effects linger at 10% effectiveness.", cost: 500000, requiredWorld: 'chronos_fault', bonus: { type: 'lingering_rituals', value: 0.1 } },
};

const rituals = {
    blood_frenzy: { name: "Blood Frenzy", desc: "Double your Souls Per Click for 30 seconds.", cost: 10000, cooldown: 300, requiredWorld: 'nether_plains', effect: { type: 'spc_multiplier', value: 2, duration: 30 } },
    demonic_horde: { name: "Demonic Horde", desc: "Double your Souls Per Second for 60 seconds.", cost: 50000, cooldown: 600, requiredWorld: 'nether_plains', effect: { type: 'sps_multiplier', value: 2, duration: 60 } },
    soul_sear: { name: "Soul Sear", desc: "Instantly gain souls equal to 10 minutes of SPS.", cost: 1e6, cooldown: 1800, requiredWorld: 'ashen_wastes', effect: { type: 'gain_sps_seconds', value: 600 } },
    essence_theft: { name: "Essence Theft", desc: "Instantly gain 1 Dark Essence.", cost: 1e8, cooldown: 3600, requiredWorld: 'stygian_depths', effect: { type: 'gain_essence', value: 1 } },
    unholy_power: { name: "Unholy Power", desc: "All soul gains are tripled for 2 minutes.", cost: 1e11, cooldown: 1800, requiredWorld: 'burning_hells', effect: { type: 'global_multiplier', value: 3, duration: 120 } },
    devils_bargain: { name: "Devil's Bargain", desc: "All minion costs are halved for 5 minutes.", cost: 1e13, cooldown: 7200, requiredWorld: 'burning_hells', effect: { type: 'temp_minion_cost_reducer', value: 0.5, duration: 300 } },
    glacial_freeze: { name: "Glacial Freeze", desc: "For 1 minute, all clicks also generate 1% of your SPS.", cost: 1e16, cooldown: 3600, requiredWorld: 'frozen_abyss', effect: { type: 'add_sps_to_spc', value: 0.01, duration: 60 } },
    divine_curse: { name: "Divine Curse", desc: "For 90s, all soul gains are multiplied by your Dark Essence count.", cost: 1e20, cooldown: 10800, requiredWorld: 'celestial_ruins', effect: { type: 'multiplier_by_essence', duration: 90 } },
    void_rupture: { name: "Void Rupture", desc: "Instantly gain 1% of the souls required for the next world.", cost: 1e24, cooldown: 86400, requiredWorld: 'void_threshold', effect: { type: 'gain_souls_for_next_world', value: 0.01 } },
    entropic_cascade: { name: "Entropic Cascade", desc: "For 30 seconds, your total soul gain is SQUARED.", cost: 1e28, cooldown: 43200, requiredWorld: 'pantheon_of_ashes', effect: { type: 'square_all_gain', duration: 30 } },
    ascendants_echo: { name: "Ascendant's Echo", desc: "Instantly gain Shards equal to 10% of your next Ascension without resetting.", cost: 1e34, cooldown: 172800, requiredWorld: 'chronos_fault', effect: { type: 'gain_shards_no_reset', value: 0.1 } },
};

const worlds = {
    nether_plains: { name: "Nether Plains", unlockCost: 0, perk: "Unlocks basic minions.", bonus: { type: 'none' }, lore: "A swirling gray expanse where the weakest and most plentiful souls wander, ripe for the taking." },
    ashen_wastes: { name: "Ashen Wastes", unlockCost: 5e4, perk: "Unlocks fire-themed minions.", bonus: { type: 'sps_multiplier', value: 1.25 }, lore: "Endless dunes of gray ash under a perpetually smoldering sky. The air crackles with embers and lost rage." },
    stygian_depths: { name: "Stygian Depths", unlockCost: 2.5e5, perk: "Unlocks aquatic demons.", bonus: { type: 'spc_multiplier', value: 1.5 }, lore: "A lightless, crushing ocean of liquid despair. Only things born of sorrow can survive here." },
    burning_hells: { name: "The Burning Hells", unlockCost: 7.5e5, perk: "Unlocks powerful lords of hell.", bonus: { type: 'global_multiplier', value: 1.2 }, lore: "A realm of jagged obsidian and rivers of fire, ruled by ancient beings of pure malice." },
    frozen_abyss: { name: "The Frozen Abyss", unlockCost: 1.5e6, perk: "Unlocks ice-themed titans.", bonus: { type: 'sps_multiplier', value: 1.5 }, lore: "A place so cold that even souls freeze solid. The silence here is a weapon." },
    celestial_ruins: { name: "Celestial Ruins", unlockCost: 8e6, perk: "Harvest the souls of fallen celestials.", bonus: { type: 'essence_bonus_chance', value: 0.001 }, lore: "The shattered remains of a forgotten heaven. The souls here are potent, tinged with both divinity and regret." },
    void_threshold: { name: "Void Threshold", unlockCost: 2.5e7, perk: "Enables Ascension. Unlocks void beings.", bonus: { type: 'ascension_unlock' }, lore: "The precipice of non-existence. Here, you learn that to truly grow, you must first become nothing." },
    singularity: { name: "The Singularity", unlockCost: 1e9, perk: "Boosts essence gain x2.", bonus: { type: 'essence_multiplier', value: 2 }, lore: "All matter, energy, and souls compressed into a single, screaming point of infinite density." },
    event_horizon: { name: "Event Horizon", unlockCost: 1e11, perk: "Beyond this, only shards matter.", bonus: { type: 'ascension_shard_bonus', value: 0.25 }, lore: "The point of no return. The power of your previous harvests is the only thing that has meaning now." },
    genesis: { name: "Genesis", unlockCost: 1e13, perk: "Doubles shard gains.", bonus: { type: 'ascension_shard_bonus', value: 1 }, lore: "The spark that came before the first bang. A realm of pure potential, waiting to be consumed and remade." },
    pantheon_of_ashes: { name: "Pantheon of Ashes", unlockCost: 1e18, perk: "Soul Resonance is twice as effective.", bonus: { type: 'resonance_bonus_enhancer', value: 1 }, lore: "The graveyard of forgotten gods. Their fading power infuses every soul you claim here." },
    chronos_fault: { name: "Chronos' Fault", unlockCost: 1e25, perk: "All ritual cooldowns are halved.", bonus: { type: 'ritual_cooldown_reducer', value: 0.5 }, lore: "A crack in time itself. The laws of cause and effect are suggestions, not rules." },
    omega_point: { name: "Omega Point", unlockCost: 1e33, perk: "All soul gains x10.", bonus: { type: 'global_multiplier', value: 10 }, lore: "The final moment of the final universe. All that was, is, and ever will be is harvested in a single, glorious instant." },
};

const items = {
    chipped_dagger: { name: "Chipped Dagger", type: "weapon", rarity: "common", desc: "+10% Souls Per Click.", bonus: { type: 'spc_multiplier', value: 1.10 } },
    soul_cleaver: { name: "Soul Cleaver", type: "weapon", rarity: "uncommon", desc: "+25% Souls Per Click.", bonus: { type: 'spc_multiplier', value: 1.25 } },
    abyssal_scythe: { name: "Abyssal Scythe", type: "weapon", rarity: "rare", desc: "+50% Souls Per Click. Your SPC contributes 0.01% to your SPS.", bonus: { type: 'spc_multiplier', value: 1.50, and: { type: 'spc_to_sps', value: 0.0001 } } },
    blade_of_the_damned: { name: "Blade of the Damned", type: "weapon", rarity: "legendary", desc: "Doubles Souls Per Click. Clicks have a 1% chance to also grant 1 Dark Essence.", bonus: { type: 'spc_multiplier', value: 2.0, and: { type: 'spc_essence_chance', value: 0.01 } } },
    cracked_effigy: { name: "Cracked Effigy", type: "idol", rarity: "common", desc: "+10% Souls Per Second.", bonus: { type: 'sps_multiplier', value: 1.10 } },
    demonic_relic: { name: "Demonic Relic", type: "idol", rarity: "uncommon", desc: "+25% Souls Per Second.", bonus: { type: 'sps_multiplier', value: 1.25 } },
    void_totem: { name: "Void Totem", type: "idol", rarity: "rare", desc: "+50% Souls Per Second. All minion costs are reduced by 5%.", bonus: { type: 'sps_multiplier', value: 1.50, and: { type: 'minion_cost_reducer', value: 0.95 } } },
    heart_of_the_horde: { name: "Heart of the Horde", type: "idol", rarity: "legendary", desc: "Doubles Souls Per Second. Gain +1% SPS for every 10 ascensions.", bonus: { type: 'sps_multiplier', value: 2.0, and: { type: 'sps_per_10_ascensions', value: 0.01 } } },
    faded_rune: { name: "Faded Rune", type: "sigil", rarity: "common", desc: "Gain 5% more Dark Essence from sacrifices.", bonus: { type: 'essence_multiplier', value: 1.05 } },
    starlit_glyph: { name: "Starlit Glyph", type: "sigil", rarity: "uncommon", desc: "+10% Abyssal Shards gained on Ascension.", bonus: { type: 'ascension_shard_bonus', value: 0.10 } },
    covenant_of_souls: { name: "Covenant of Souls", type: "sigil", rarity: "rare", desc: "Soul Resonance is 20% more effective.", bonus: { type: 'resonance_bonus_enhancer', value: 0.20 } },
    mark_of_the_first: { name: "Mark of the First", type: "sigil", rarity: "legendary", desc: "Your first purchase of each minion per run is free.", bonus: { type: 'first_minion_free' } },
    iron_mask: { name: "Iron Mask", type: "helm", rarity: "common", desc: "In PvP Duels, you take 10% less passive damage.", bonus: { type: 'pvp_defense', value: 0.90 } },
    gaze_of_terror: { name: "Gaze of Terror", type: "helm", rarity: "uncommon", desc: "In PvP Duels, the opponent's passive damage is reduced by 25%.", bonus: { type: 'pvp_defense', value: 0.75 } },
    crown_of_dominance: { name: "Crown of Dominance", type: "helm", rarity: "rare", desc: "In PvP Duels, your click damage is increased by 50%.", bonus: { type: 'pvp_offense', value: 1.50 } },
    helm_of_the_conqueror: { name: "Helm of the Conqueror", type: "helm", rarity: "legendary", desc: "Start PvP Duels with a 2-second head start before the opponent deals damage.", bonus: { type: 'pvp_headstart', value: 2 } },
};

const potions = {
    draught_of_might: { name: "Draught of Might", desc: "For 60 seconds, your Souls Per Click is increased by 25% of your Souls Per Second.", cost: 1e6, effect: { type: 'add_sps_to_spc_flat', value: 0.25, duration: 60 } },
    ichor_of_wealth: { name: "Ichor of Wealth", desc: "Instantly gain souls equal to 30 minutes of your current SPS.", cost: 1e7, effect: { type: 'gain_sps_seconds_flat', value: 1800 } },
    elixir_of_wisdom: { name: "Elixir of Wisdom", desc: "For 5 minutes, all minions cost 10% less.", cost: 1e8, effect: { type: 'temp_minion_cost_reducer_flat', value: 0.90, duration: 300 } },
    brew_of_the_void: { name: "Brew of the Void", desc: "Instantly gain 2 Dark Essence.", cost: 1e9, costType: 'souls_and_shards', shardsCost: 1, effect: { type: 'gain_essence_flat', value: 2 } }
};

// =================================================================
// GAME STATE & CORE LOGIC
// =================================================================

let gameState = {};
let duelState = {};

const antiCheatState = {
    clickTimestamps: [],
    clickIntervals: [],
    punishmentLevel: 0,
    isLockedOut: false
};

function getDefaultGameState() {
    const newMinionsState = {};
    for (const id in minions) {
        newMinionsState[id] = {
            level: 0,
            cost: minions[id].cost
        };
    }

    return {
        playerName: "Unnamed",
        souls: 0,
        lifetimeSouls: 0,
        darkEssence: 0,
        abyssalShards: 0,
        ascensions: 0,
        currentWorld: 'nether_plains',
        unlockedWorlds: ['nether_plains'],
        stats: {
            sps: 0,
            spc: 1
        },
        upgrades: {
            click: {
                level: 1,
                cost: 10,
                multiplier: 1.12
            },
            sacrifice: {
                cost: 1000,
                multiplier: 2.5
            },
            resonance: {
                level: 0,
                cost: 5,
                multiplier: 2
            },
        },
        minions: newMinionsState,
        ownedArtifacts: {},
        activeRituals: {},
        potions: {},
        activePotions: {},
        inventory: [],
        equipped: {
            weapon: null,
            idol: null,
            sigil: null,
            helm: null,
        },
        nextCacheTime: 0,
        pvpWins: 0,
        pvpLosses: 0,
        attackLog: [],
        raidCooldownEnd: 0,
    };
}
// =================================================================
// INITIALIZATION & GAME LOOP
// =================================================================
window.onload = function() {
    loadGame();
    calculateStats();
    renderAll();
    initRift();
    let tickCounter = 0;
    const TICKS_PER_SECOND = 10;
    setInterval(() => {
        const now = Date.now();
        const passiveGain = gameState.stats.sps / TICKS_PER_SECOND;
        gameState.souls += passiveGain;
        gameState.lifetimeSouls += passiveGain;
        updateDynamicDisplays();
        tickCounter++;
        if (tickCounter % TICKS_PER_SECOND === 0) {
            let statsChanged = updateEffectTimers(now);
            if(statsChanged) {
                calculateStats();
                renderAll();
            } else {
                checkButtons();
            }
            updateAscensionPreview();
            updateCacheTimer();
            updateRaidCooldownDisplay();
        }
        if (tickCounter % (TICKS_PER_SECOND * 15) === 0) {
            saveGame();
        }
    }, 1000 / TICKS_PER_SECOND);
};
function createProfile() { const nameInput = document.getElementById('playerNameInput'); if (nameInput.value.trim() === '') { alert("A name is required."); return; } gameState.playerName = nameInput.value.trim(); document.getElementById('profile-setup').style.display = 'none'; document.getElementById('game-container').style.display = 'block'; audio.bgm.play().catch(e=>console.log("Audio autoplay blocked.")); saveGame(); renderAll(); }
async function saveGame() {
    localStorage.setItem('soulCollectorSave_v3', JSON.stringify(gameState));
    if (!supabase || gameState.playerName === "Unnamed") {
        return;
    }

    const publicData = {
        name: gameState.playerName,
        lifetimeSouls: gameState.lifetimeSouls,
        ascensions: gameState.ascensions,
        pvpWins: gameState.pvpWins,
        pvpLosses: gameState.pvpLosses,
        bin_id: gameState.playerName,
    };

    try {
        const { error } = await supabase
            .from('players')
            .upsert(publicData, { onConflict: 'name' }); 
        if (error) throw error;
        console.log("PvP data synced with Supabase.");
    } catch (error) {
        console.error("Failed to sync PvP data with Supabase:", error.message);
    }
}
function loadGame() {
    const savedGame = localStorage.getItem('soulCollectorSave_v3');
    const defaultState = getDefaultGameState();
    if (savedGame) {
        try {
            let loadedState = JSON.parse(savedGame);
            gameState = deepMerge(defaultState, loadedState);
            document.getElementById('game-container').style.display = 'block';
            audio.bgm.play().catch(e => {});
        } catch (e) {
            console.error("Error parsing save. Starting fresh.", e);
            gameState = defaultState;
            document.getElementById('profile-setup').style.display = 'flex';
        }
    } else {
        gameState = defaultState;
        document.getElementById('profile-setup').style.display = 'flex';
    }
}
function deepMerge(target, source) {
    for (const key in source) {
        if (source[key] instanceof Object && key in target) {
            Object.assign(source[key], deepMerge(target[key], source[key]));
        }
    }
    Object.assign(target || {}, source);
    return target;
}
// =================================================================
// CORE GAMEPLAY FUNCTIONS
// =================================================================
function harvestSoul() {
    if (antiCheatState.isLockedOut) return;
    const gain = gameState.stats.spc;
    gameState.souls += gain;
    gameState.lifetimeSouls += gain;
    const btn = document.querySelector('.action-btn');
    btn.classList.remove('thump-animation');
    void btn.offsetWidth;
    btn.classList.add('thump-animation');
    audio.harvest.currentTime=0;
    audio.harvest.play();
    const rect = btn.getBoundingClientRect();
    for (let i = 0; i < 5; i++) {
        const particle = document.createElement('div');
        particle.className = 'soul-particle';
        document.body.appendChild(particle);
        particle.style.left = `${rect.left + rect.width / 2}px`;
        particle.style.top = `${rect.top + rect.height / 2}px`;
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * 80 + 50;
        particle.style.setProperty('--x', `${Math.cos(angle) * distance}px`);
        particle.style.setProperty('--y', `${Math.sin(angle) * distance}px`);
        setTimeout(() => particle.remove(), 800);
    }
    const worldBonus = worlds[gameState.currentWorld].bonus;
    if (worldBonus.type === 'essence_bonus_chance' && Math.random() < worldBonus.value) gameState.darkEssence += 1;
    const weaponId = gameState.equipped.weapon;
    if (weaponId && items[weaponId]) {
        let bonus = items[weaponId].bonus;
        do {
            if (bonus.type === 'spc_essence_chance' && Math.random() < bonus.value) gameState.darkEssence += 1;
            bonus = bonus.and ? bonus.and : null;
        } while (bonus);
    }
    
    // V V V V V V V V V V V V V V V V V V V V V V
    // THIS IS THE LINE IM FOR WELL YOU KNOW WHAT
        runAntiCheatChecks(); 
    // ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
    
    updateDynamicDisplays();
} // <-- The function ends here
function buyUpgrade(type) { const upgrade = gameState.upgrades[type]; if (type === 'click' || type === 'sacrifice') { if (gameState.souls < upgrade.cost) return; gameState.souls -= upgrade.cost; if (type === 'click') { upgrade.level++; } else if (type === 'sacrifice') {
    let essenceGain = 1;
    let multi = 1;
    Object.keys(gameState.ownedArtifacts).forEach(id => {
        const bonus = artifacts[id]?.bonus;
        if (bonus && bonus.type === 'essence_multiplier') multi *= bonus.value;
    });
    essenceGain *= multi;
    if (gameState.equipped.sigil && items[gameState.equipped.sigil]?.bonus.type === 'essence_multiplier') essenceGain *= items[gameState.equipped.sigil].bonus.value;
    gameState.darkEssence += Math.floor(essenceGain);

    // V V V V V V V V V V V V V V V V V V V V V V V V
    // THIS IS THE NEW LINE YOU ARE ADDING!
    upgrade.cost = Math.floor(upgrade.cost * 2);
    // ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^

} } else if (type === 'resonance') { if (gameState.darkEssence < upgrade.cost) return; gameState.darkEssence -= upgrade.cost; upgrade.level++; } audio.click.play(); calculateStats(); renderAll(); saveGame(); }
function buyMinion(id) {
    const minionData = minions[id];
    const playerMinion = gameState.minions[id];
    if (gameState.souls >= playerMinion.cost) {
        gameState.souls -= playerMinion.cost;
        playerMinion.level++;
        audio.click.play();
        calculateStats();
        renderMinions();
        checkButtons();
        saveGame();
    }
}

function buyArtifact(id) {
    const artifactData = artifacts[id];
    if (gameState.darkEssence >= artifactData.cost && !gameState.ownedArtifacts[id]) {
        gameState.darkEssence -= artifactData.cost;
        gameState.ownedArtifacts[id] = true;
        audio.click.play();
        calculateStats();
        renderAll();
        saveGame();
    }
}

function activateRitual(id) {
    const ritualData = rituals[id];
    const effect = ritualData.effect;
    let ritualDuration = effect.duration || 0;
    let ritualCooldown = ritualData.cooldown;

    Object.keys(gameState.ownedArtifacts).forEach(artId => {
        const bonus = artifacts[artId]?.bonus;
        if (bonus) {
            if (bonus.type === 'ritual_cooldown_reducer') ritualCooldown *= bonus.value;
            if (bonus.type === 'ritual_duration_multiplier') ritualDuration *= bonus.value;
        }
    });

    if (gameState.souls >= ritualData.cost && !gameState.activeRituals[id]) {
        gameState.souls -= ritualData.cost;
        if (effect.type === 'gain_essence') gameState.darkEssence += effect.value;
        if (effect.type === 'gain_sps_seconds') gameState.souls += gameState.stats.sps * effect.value;
        if (effect.type === 'gain_souls_for_next_world') {
            const worldKeys = Object.keys(worlds);
            const currentWorldIndex = worldKeys.indexOf(gameState.currentWorld);
            const nextWorldId = worldKeys[currentWorldIndex + 1];
            if (nextWorldId && worlds[nextWorldId]) {
                gameState.souls += worlds[nextWorldId].unlockCost * effect.value;
            }
        }
        if (effect.type === 'gain_shards_no_reset') {
            gameState.abyssalShards += Math.floor(calculateShardsOnAscend() * effect.value);
        }

        const now = Date.now();
        gameState.activeRituals[id] = {
            cooldownEndTime: now + (ritualCooldown * 1000),
            buffEndTime: ritualDuration > 0 ? now + (ritualDuration * 1000) : null
        };
        audio.click.play();
        calculateStats();
        renderAll();
        saveGame();
    }
}

function performAscension() {
    if (!gameState.unlockedWorlds.includes('void_threshold')) {
        return;
    }
    const shardsGained = calculateShardsOnAscend();
    if (shardsGained < 1) {
        alert("You have not harvested enough souls to gain any Abyssal Shards.");
        return;
    }

    const oldState = gameState;
    gameState = getDefaultGameState();
    gameState.playerName = oldState.playerName;
    gameState.abyssalShards = oldState.abyssalShards + shardsGained;
    gameState.ownedArtifacts = oldState.ownedArtifacts;
    gameState.ascensions = oldState.ascensions + 1;
    gameState.upgrades.resonance = oldState.upgrades.resonance;
    gameState.pvpWins = oldState.pvpWins;
    gameState.pvpLosses = oldState.pvpLosses;

    audio.ascend.play();
    calculateStats();
    renderAll();
    showScreen('altar');
    saveGame();
}

function calculateShardsOnAscend() {
    let resonanceEffect = 0.05 * (1 + (artifacts.scroll_of_heresy && gameState.ownedArtifacts['scroll_of_heresy'] ? artifacts.scroll_of_heresy.bonus.value : 0));
    let resonanceBonus = 1 + (gameState.upgrades.resonance.level * resonanceEffect);
    let baseShards = Math.floor(Math.pow(gameState.lifetimeSouls / 1e7, 0.5));
    let totalShards = baseShards * resonanceBonus;
    let shardMultiplier = 1;

    Object.keys(gameState.ownedArtifacts).forEach(id => {
        const bonus = artifacts[id]?.bonus;
        if (bonus && bonus.type === 'ascension_shard_bonus') {
            shardMultiplier += bonus.value;
        }
    });

    gameState.unlockedWorlds.forEach(id => {
        const bonus = worlds[id]?.bonus;
        if (bonus && bonus.type === 'ascension_shard_bonus') {
            shardMultiplier += bonus.value;
        }
    });

    totalShards *= shardMultiplier;
    return Math.floor(totalShards);
}

function updateAscensionPreview() {
    document.getElementById('shardsOnAscend').innerText = formatNumber(calculateShardsOnAscend());
}

function calculateStats() {
    let baseSpc = 1 + (gameState.upgrades.click.level - 1) * 2.5;
    let sps = 0,
        spc_multiplier = 1,
        sps_multiplier = 1,
        global_multiplier = 1,
        minionCostFactor = 1,
        clickUpgradeCostFactor = 1,
        prestigeBonusEnhancer = 1;
    let tempMinionCostFactor = 1;
    let isGainSquared = false;

    for (const slot in gameState.equipped) {
        const itemId = gameState.equipped[slot];
        if (itemId && items[itemId]) {
            let bonus = items[itemId].bonus;
            do {
                if (bonus.type === 'minion_cost_reducer') minionCostFactor *= bonus.value;
                bonus = bonus.and ? bonus.and : null;
            } while (bonus);
        }
    }

    for (const id in gameState.activeRituals) {
        const ritualState = gameState.activeRituals[id];
        if (Date.now() < ritualState.buffEndTime) {
            const effect = rituals[id].effect;
            if (effect.type === 'spc_multiplier') spc_multiplier *= effect.value;
            if (effect.type === 'sps_multiplier') sps_multiplier *= effect.value;
            if (effect.type === 'global_multiplier') global_multiplier *= effect.value;
            if (effect.type === 'temp_minion_cost_reducer') tempMinionCostFactor *= effect.value;
            if (effect.type === 'multiplier_by_essence') global_multiplier *= (gameState.darkEssence || 1);
            if (effect.type === 'square_all_gain') isGainSquared = true;
        }
    }

    Object.keys(gameState.ownedArtifacts).forEach(id => {
        const bonus = artifacts[id]?.bonus;
        if (!bonus) return;
        if (bonus.type === 'minion_cost_reducer') minionCostFactor *= bonus.value;
        if (bonus.type === 'upgrade_cost_reducer' && bonus.target === 'click') clickUpgradeCostFactor *= bonus.value;
        if (bonus.type === 'prestige_bonus_enhancer') prestigeBonusEnhancer *= bonus.value;
        if (bonus.type === 'global_multiplier_per_artifact') global_multiplier += (bonus.value * Object.keys(gameState.ownedArtifacts).length);
        if (bonus.type === 'global_multiplier_per_world') global_multiplier += (bonus.value * gameState.unlockedWorlds.length);
        if (bonus.type === 'global_multiplier_per_ascension') global_multiplier += (bonus.value * gameState.ascensions);
        if (bonus.type === 'global_multiplier_by_ascensions' && gameState.ascensions > 0) global_multiplier *= gameState.ascensions;
    });

    for (const id in gameState.minions) {
        if (gameState.minions[id].level > 0) {
            let minionSps = gameState.minions[id].level * minions[id].baseSps;
            Object.keys(gameState.ownedArtifacts).forEach(artId => {
                const bonus = artifacts[artId]?.bonus;
                if (bonus && bonus.type === 'minion_specific_multiplier' && bonus.target.includes(id)) {
                    minionSps *= bonus.value;
                }
            });
            sps += minionSps;
        }
    }

    for (const slot in gameState.equipped) {
        const itemId = gameState.equipped[slot];
        if (itemId && items[itemId]) {
            let bonus = items[itemId].bonus;
            do {
                if (bonus.type === 'spc_multiplier') spc_multiplier *= bonus.value;
                if (bonus.type === 'sps_multiplier') sps_multiplier *= bonus.value;
                if (bonus.type === 'sps_per_10_ascensions') sps_multiplier += Math.floor(gameState.ascensions / 10) * bonus.value;
                bonus = bonus.and ? bonus.and : null;
            } while (bonus);
        }
    }

    const worldBonus = worlds[gameState.currentWorld].bonus;
    if (worldBonus.type === 'sps_multiplier') sps_multiplier *= worldBonus.value;
    if (worldBonus.type === 'spc_multiplier') spc_multiplier *= worldBonus.value;
    if (worldBonus.type === 'global_multiplier') global_multiplier *= worldBonus.value;

    const prestige_bonus = Math.pow(1.1 * prestigeBonusEnhancer, gameState.abyssalShards);
    global_multiplier *= prestige_bonus;

    let final_sps = sps * sps_multiplier * global_multiplier;
    let final_spc = baseSpc * spc_multiplier * global_multiplier;

    if (isGainSquared) {
        final_sps = Math.pow(final_sps, 2);
        final_spc = Math.pow(final_spc, 2);
    }

    gameState.stats.sps = final_sps;
    gameState.stats.spc = final_spc;

    gameState.upgrades.click.cost = Math.floor(10 * Math.pow(gameState.upgrades.click.multiplier, gameState.upgrades.click.level - 1) * clickUpgradeCostFactor);

    for (const minionId in minions) {
        const minionData = minions[minionId];
        const playerMinion = gameState.minions[minionId];
        const baseMinionCost = minionData.cost * Math.pow(minionData.multiplier, playerMinion.level);
        let finalMinionCostFactor = minionCostFactor * tempMinionCostFactor;
        const sigilId = gameState.equipped.sigil;
        if (sigilId && items[sigilId] && items[sigilId].bonus.type === 'first_minion_free' && playerMinion.level === 0) {
            finalMinionCostFactor = 0;
        }
        playerMinion.cost = Math.floor(baseMinionCost * finalMinionCostFactor);
    }
}

// =================================================================
// UI RENDERING & UPDATES
// =================================================================

function renderAll() {
    if (!gameState || !gameState.currentWorld) {
        return;
    }
    document.getElementById('playerName-display').innerText = gameState.playerName;
    document.getElementById('world-title').innerText = worlds[gameState.currentWorld].name;
    renderAltar();
    renderMinions();
    renderBrewery();
    renderInventory();
    renderArtifacts();
    renderRituals();
    renderMap();
    renderAscensionScreen();
    fetchLeaderboard();
    fetchPvpTargets();
    renderPvpLog();
    updateDynamicDisplays();
    checkButtons();
}

function updateDynamicDisplays() {
    document.getElementById('souls-display').innerText = formatNumber(gameState.souls);
    document.getElementById('essence-display').innerText = formatNumber(gameState.darkEssence);
    document.getElementById('shards-display').innerText = formatNumber(gameState.abyssalShards);
    document.getElementById('sps-display').innerText = formatNumber(gameState.stats.sps);
    document.getElementById('spc-display').innerText = formatNumber(gameState.stats.spc);
}

function checkButtons() {
    document.getElementById('clickUpgradeBtn').disabled = gameState.souls < gameState.upgrades.click.cost;
    document.getElementById('sacrificeBtn').disabled = gameState.souls < gameState.upgrades.sacrifice.cost;
    document.getElementById('resonanceUpgradeBtn').disabled = gameState.darkEssence < gameState.upgrades.resonance.cost;

    for (const id in minions) {
        const btn = document.getElementById(`minion-btn-${id}`);
        if (btn) btn.disabled = gameState.souls < gameState.minions[id].cost;
    }
    for (const id in artifacts) {
        const btn = document.getElementById(`artifact-btn-${id}`);
        if (btn) btn.disabled = gameState.darkEssence < artifacts[id].cost || !!gameState.ownedArtifacts[id];
    }
    for (const id in rituals) {
        const btn = document.getElementById(`ritual-btn-${id}`);
        if (btn) btn.disabled = gameState.souls < rituals[id].cost || !!gameState.activeRituals[id];
    }
    document.getElementById('ascendBtn').disabled = !gameState.unlockedWorlds.includes('void_threshold');
}

function showScreen(screenId) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(screenId + '-screen').classList.add('active');
    document.querySelectorAll('nav button').forEach(b => b.classList.remove('active'));
    document.querySelector(`nav button[onclick="showScreen('${screenId}')"]`).classList.add('active');
    audio.click.play();
}

function renderAltar() {
    document.getElementById('clickLevel').innerText = gameState.upgrades.click.level;
    document.getElementById('clickCost').innerText = formatNumber(gameState.upgrades.click.cost);
    document.getElementById('sacrificeCost').innerText = formatNumber(gameState.upgrades.sacrifice.cost);
    document.getElementById('resonanceLevel').innerText = gameState.upgrades.resonance.level;
    document.getElementById('resonanceCost').innerText = formatNumber(gameState.upgrades.resonance.cost);
}

function renderMinions() {
    const grid = document.getElementById('minion-grid');
    grid.innerHTML = '';
    for (const id in minions) {
        if (gameState.unlockedWorlds.includes(minions[id].requiredWorld)) {
            const m = minions[id];
            const p = gameState.minions[id];
            grid.innerHTML += `<button class="upgrade-btn" id="minion-btn-${id}" onclick="buyMinion('${id}')"><span class="btn-title">${m.name}</span> (+${formatNumber(m.baseSps)} SPS/lvl)<br><span class="btn-level">Level: ${p.level}</span><br><span class="cost">Cost: <span class="cost-souls">${formatNumber(p.cost)}</span></span></button>`;
        }
    }
}

function renderInventory() {
    const equippedGrid = document.getElementById('equipped-items-grid');
    const inventoryGrid = document.getElementById('inventory-items-grid');
    if (!equippedGrid || !inventoryGrid) {
        return;
    }
    equippedGrid.innerHTML = '';
    inventoryGrid.innerHTML = '';

    if (Object.values(gameState.equipped).every(val => val === null)) {
        equippedGrid.innerHTML = `<p style="color:var(--dim-color)">No items equipped.</p>`;
    } else {
        for (const slot in gameState.equipped) {
            const itemId = gameState.equipped[slot];
            if (itemId) {
                const item = items[itemId];
                equippedGrid.innerHTML += `<div class="upgrade-btn owned" data-tooltip="${item.desc}"><span class="btn-title" style="color:var(--accent-color);">${item.name} (Equipped)</span><br><span>Type: ${slot.charAt(0).toUpperCase() + slot.slice(1)}</span></div>`;
            }
        }
    }

    if (gameState.inventory.length === 0) {
        inventoryGrid.innerHTML = `<p style="color:var(--dim-color)">Your inventory is empty. Open an Abyssal Cache!</p>`;
    } else {
        gameState.inventory.forEach(itemId => {
            const item = items[itemId];
            inventoryGrid.innerHTML += `<button class="upgrade-btn" onclick="equipItem('${itemId}')"><span class="btn-title">${item.name}</span><br><span>${item.desc}</span><br><span class="cost">Type: <span class="cost-essence">${item.type.charAt(0).toUpperCase() + item.type.slice(1)}</span></span></button>`;
        });
    }
}

function equipItem(itemId) {
    const itemToEquip = items[itemId];
    if (!itemToEquip) return;

    const itemIndex = gameState.inventory.indexOf(itemId);
    if (itemIndex === -1) return;

    const slot = itemToEquip.type;
    const currentlyEquippedId = gameState.equipped[slot];

    if (currentlyEquippedId) {
        gameState.inventory.push(currentlyEquippedId);
    }
    gameState.inventory.splice(itemIndex, 1);
    gameState.equipped[slot] = itemId;

    audio.click.play();
    calculateStats();
    renderAll();
    saveGame();
}

function renderArtifacts() {
    const grid = document.getElementById('artifact-grid');
    grid.innerHTML = '';
    for (const id in artifacts) {
        if (gameState.unlockedWorlds.includes(artifacts[id].requiredWorld)) {
            const a = artifacts[id];
            const isOwned = !!gameState.ownedArtifacts[id];
            grid.innerHTML += `<button class="upgrade-btn ${isOwned ? 'owned' : ''}" id="artifact-btn-${id}" onclick="buyArtifact('${id}')" ${isOwned ? 'disabled' : ''}><span class="btn-title">${a.name}</span><br><span>${a.desc}</span><br><span class="cost">Cost: <span class="cost-essence">${formatNumber(a.cost)}</span></span></button>`;
        }
    }
}

function renderBrewery() {
    const recipeGrid = document.getElementById('potion-recipe-grid');
    const inventoryGrid = document.getElementById('potion-inventory');
    if (!recipeGrid || !inventoryGrid) return;
    recipeGrid.innerHTML = '';
    inventoryGrid.innerHTML = '';

    for (const id in potions) {
        const p = potions[id];
        let canAfford = gameState.souls >= p.cost;
        let costString = `Cost: <span class="cost-souls">${formatNumber(p.cost)}</span>`;
        if (p.costType === 'souls_and_shards') {
            canAfford = gameState.souls >= p.cost && gameState.abyssalShards >= p.shardsCost;
            costString += ` + <span class="cost-shards">${formatNumber(p.shardsCost)} Shards</span>`;
        }
        recipeGrid.innerHTML += `<button class="upgrade-btn" onclick="brewPotion('${id}')" ${canAfford ? '' : 'disabled'}><span class="btn-title">${p.name}</span><br><span>${p.desc}</span><br><span class="cost">${costString}</span></button>`;
    }

    let hasPotions = false;
    for (const id in gameState.potions) {
        if (gameState.potions[id] > 0) {
            hasPotions = true;
            const count = gameState.potions[id];
            const isActive = gameState.activePotions[id] && Date.now() < gameState.activePotions[id];
            let buttonContent = isActive ? `<span style="color:var(--prestige-color); font-style:italic;">Active...</span>` : `<span style="color:var(--accent-color); font-style:italic;">Click to Use</span>`;
            if (potions[id]) {
                inventoryGrid.innerHTML += `<button class="upgrade-btn" onclick="usePotion('${id}')" ${isActive ? 'disabled' : ''}><span class="btn-title">${potions[id].name} (x${count})</span><br>${buttonContent}</button>`;
            }
        }
    }
    if (!hasPotions) {
        inventoryGrid.innerHTML = `<p style="color:var(--dim-color)">You have no potions. Brew some!</p>`;
    }
}

function updateEffectTimers(now) {
    let shouldRecalculate = false;
    for (const id in gameState.activeRituals) {
        if (gameState.activeRituals[id].buffEndTime && now >= gameState.activeRituals[id].buffEndTime) {
            shouldRecalculate = true;
        }
    }
    for (const id in gameState.activePotions) {
        if (now >= gameState.activePotions[id]) {
            shouldRecalculate = true;
        }
    }
    return shouldRecalculate;
}

function brewPotion(id) {
    const p = potions[id];
    let canAfford = gameState.souls >= p.cost;
    if (p.costType === 'souls_and_shards') {
        canAfford = gameState.souls >= p.cost && gameState.abyssalShards >= p.shardsCost;
    }

    if (canAfford) {
        gameState.souls -= p.cost;
        if (p.shardsCost) gameState.abyssalShards -= p.shardsCost;
        gameState.potions[id] = (gameState.potions[id] || 0) + 1;
        audio.click.play();
        renderBrewery();
        checkButtons();
    }
}

function usePotion(id) {
    if (gameState.potions[id] > 0) {
        gameState.potions[id]--;
        const effect = potions[id].effect;
        if (effect.type === 'gain_sps_seconds_flat') gameState.souls += gameState.stats.sps * effect.value;
        if (effect.type === 'gain_essence_flat') gameState.darkEssence += effect.value;
        if (effect.duration) {
            gameState.activePotions[id] = Date.now() + (effect.duration * 1000);
        }
        audio.click.play();
        calculateStats();
        renderAll();
    }
}

function updateCacheTimer() {
    const now = Date.now();
    const btn = document.getElementById('abyssal-cache-btn');
    if (!btn) return;

    const timerText = document.getElementById('cache-timer-text');
    const readyText = document.getElementById('cache-ready-text');

    if (now < gameState.nextCacheTime) {
        btn.disabled = true;
        const timeLeft = gameState.nextCacheTime - now;
        const hours = Math.floor(timeLeft / 3600000);
        const minutes = Math.floor((timeLeft % 3600000) / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);
        timerText.textContent = `${hours}h ${minutes}m ${seconds}s`;
        readyText.textContent = "ABYSSAL CACHE";
    } else {
        btn.disabled = false;
        readyText.textContent = "CACHE READY";
        timerText.textContent = "Click to Open!";
    }
}

function openAbyssalCache() {
    if (Date.now() < gameState.nextCacheTime) return;

    const itemKeys = Object.keys(items);
    const randomItemId = itemKeys[Math.floor(Math.random() * itemKeys.length)];
    const rewardItem = items[randomItemId];
    gameState.inventory.push(randomItemId);

    const modal = document.getElementById('item-modal-overlay');
    const rewardDiv = document.getElementById('item-modal-reward');
    rewardDiv.innerHTML = `<div class="item-name" style="color:var(--accent-color);">${rewardItem.name}</div><div class="item-desc">${rewardItem.desc}</div>`;
    modal.style.display = 'flex';

    gameState.nextCacheTime = Date.now() + 4 * 3600000;
    updateCacheTimer();
    audio.ascend.play();
}

function closeItemModal() {
    document.getElementById('item-modal-overlay').style.display = 'none';
    renderInventory();
}

function closeLoreModal() {
    document.getElementById('lore-modal-overlay').style.display = 'none';
}

function renderRituals() {
    const grid = document.getElementById('ritual-grid');
    grid.innerHTML = '';
    for (const id in rituals) {
        if (gameState.unlockedWorlds.includes(rituals[id].requiredWorld)) {
            const r = rituals[id];
            const active = !!gameState.activeRituals[id] && Date.now() < gameState.activeRituals[id].cooldownEndTime;
            grid.innerHTML += `<button class="upgrade-btn" id="ritual-btn-${id}" onclick="activateRitual('${id}')" ${active ? 'disabled' : ''}><span class="btn-title">${r.name}</span><br><span>${r.desc}</span><br><span class="cost">Cost: <span class="cost-souls">${formatNumber(r.cost)}</span></span></button>`;
        }
    }
}

function renderMap() {
    const grid = document.getElementById('map-grid');
    grid.innerHTML = '';
    for (const id in worlds) {
        const w = worlds[id];
        const isUnlocked = gameState.unlockedWorlds.includes(id);
        const isActive = gameState.currentWorld === id;
        const li = document.createElement('li');
        if (isActive) {
            li.classList.add('active-world');
        }
        let buttonHtml = isUnlocked ?
            `<button class="upgrade-btn" onclick="travelToWorld('${id}')" ${isActive ? 'disabled' : ''}>Travel</button>` :
            `<button class="upgrade-btn" onclick="travelToWorld('${id}')" ${gameState.souls < w.unlockCost ? 'disabled' : ''}>Unlock (${formatNumber(w.unlockCost)})</button>`;
        li.innerHTML = `<div><strong>${w.name}</strong><br><small style="color:var(--prestige-color)">${w.perk}</small></div> ${buttonHtml}`;
        grid.appendChild(li);
    }
}

function travelToWorld(id) {
    const isUnlocked = gameState.unlockedWorlds.includes(id);
    if (isUnlocked) {
        gameState.currentWorld = id;
    } else if (gameState.souls >= worlds[id].unlockCost) {
        gameState.souls -= worlds[id].unlockCost;
        gameState.unlockedWorlds.push(id);
        gameState.currentWorld = id;
        showLore(id);
    }
    audio.click.play();
    calculateStats();
    renderAll();
    saveGame();
}

function showLore(worldId) {
    const lore = worlds[worldId].lore;
    if (!lore) return;
    document.getElementById('lore-modal-title').innerText = `Welcome to ${worlds[worldId].name}`;
    document.getElementById('lore-modal-text').innerText = lore;
    document.getElementById('lore-modal-overlay').style.display = 'flex';
}

function renderAscensionScreen() {
    document.getElementById('ascendBtn').disabled = !gameState.unlockedWorlds.includes('void_threshold');
}
// =================================================================
// PVP & LEADERBOARD FUNCTIONS
// =================================================================
// =================================================================
// PVP & LEADERBOARD FUNCTIONS (SUPABASE VERSION)
// =================================================================
async function fetchLeaderboard(type = 'lifetimeSouls') {
    const list = document.getElementById('leaderboard-list');
    const title = document.getElementById('leaderboard-title');
    if (!list || !title || !supabase) {
        list.innerHTML = `<li>PvP Database not configured.</li>`;
        return;
    }
    list.innerHTML = '<li><em>Summoning spirits...</em></li>';
    try {
        const { data, error } = await supabase
            .from('players')
            .select('*')
            .order(type, { ascending: false })
            .limit(10);
        if (error) throw error;
        let players = data;
        let rankingMetric = 'Souls';
        switch (type) {
            case 'ascensions': rankingMetric = 'Ascensions'; title.innerText = 'Ranking by Ascensions'; break;
            case 'pvpWins': rankingMetric = 'Wins'; title.innerText = 'Ranking by PvP Wins'; break;
            default: rankingMetric = 'Souls'; title.innerText = 'Ranking by Total Souls'; break;
        }
        list.innerHTML = '';
        players.forEach((player, index) => {
            const li = document.createElement('li');
            let value = (type === 'ascensions') ? (player.ascensions || 0) : (type === 'pvpWins') ? (player.pvpWins || 0) : formatNumber(player.lifetimeSouls || 0);
            li.innerHTML = `<span>#${index + 1} ${player.name}</span> <span>${value} ${rankingMetric}</span>`;
            if (player.name === gameState.playerName) li.style.cssText = 'color: var(--primary-color); font-weight: bold;';
            list.appendChild(li);
        });
    } catch (e) {
        list.innerHTML = `<li>Error summoning spirits.</li>`;
        console.error(e);
    }
}

async function fetchPvpTargets() {
    const targetList = document.getElementById('pvp-target-list');
    if (!targetList || !supabase) {
        targetList.innerHTML = `<li>PvP Database not configured.</li>`;
        return;
    }
    targetList.innerHTML = '<li><em>Scouring the abyss for rivals...</em></li>';
    try {
        const { data, error } = await supabase
            .from('players')
            .select('*')
            .neq('name', gameState.playerName)
            .gte('lifetimeSouls', gameState.lifetimeSouls * 0.5)
            .lte('lifetimeSouls', gameState.lifetimeSouls * 2);
        if (error) throw error;
        const potentialTargets = data.sort(() => 0.5 - Math.random()).slice(0, 5);
        window.potentialTargetsData = data;
        targetList.innerHTML = '';
        if (potentialTargets.length === 0) {
            targetList.innerHTML = `<li>No suitable targets found in your soul range. Keep harvesting!</li>`;
            return;
        }
        potentialTargets.forEach(player => {
            const li = document.createElement('li');
            li.innerHTML = `<span>${player.name} (Wins: ${player.pvpWins || 0})</span> <button class="upgrade-btn" style="width: 100px;" onclick="raidPlayer('${player.name}')">Raid</button>`;
            targetList.appendChild(li);
        });
    } catch(e) {
        targetList.innerHTML = `<li>Error finding targets.</li>`;
        console.error("Detailed PvP Error:", e);
    }
}

function raidPlayer(targetName) {
    if (Date.now() < gameState.raidCooldownEnd) {
        alert("Your raiding parties are exhausted. Wait for the cooldown.");
        return;
    }
    if (!window.potentialTargetsData) {
        alert("Target data not found! Please find new opponents first.");
        return;
    }
    const defender = window.potentialTargetsData.find(p => p.name === targetName);
    if (!defender) {
        alert("Target has vanished!");
        return;
    }
    duelState = {
        active: true, timer: 15, opponent: defender, opponentMaxHealth: (defender.lifetimeSouls || 1e9) / 1e5,
        opponentCurrentHealth: (defender.lifetimeSouls || 1e9) / 1e5, playerMaxHealth: (gameState.lifetimeSouls || 1e6) / 1e5,
        playerCurrentHealth: (gameState.lifetimeSouls || 1e6) / 1e5, opponentDamagePerSecond: (defender.lifetimeSouls || 1e9) / 1e8, playerDamageMultiplier: 1,
    };
    const helmId = gameState.equipped.helm;
    if (helmId && items[helmId]) {
        const bonus = items[helmId].bonus;
        if (bonus.type === 'pvp_defense') duelState.opponentDamagePerSecond *= bonus.value;
        if (bonus.type === 'pvp_offense') duelState.playerDamageMultiplier = bonus.value;
        if (bonus.type === 'pvp_headstart') duelState.playerDamageImmuneUntil = Date.now() + (bonus.value * 1000);
    }
    document.getElementById('duel-overlay').style.display = 'flex';
    document.getElementById('opponent-name').innerText = `VS ${defender.name}`;
    updateDuelUI();
    duelState.gameInterval = setInterval(duelGameLoop, 100);
    duelState.weakPointInterval = setInterval(spawnWeakPoint, 1500);
}

function renderPvpLog() { const logList = document.getElementById('pvp-log-list'); if(!logList) return; logList.innerHTML = ''; if (!gameState.attackLog || gameState.attackLog.length === 0) { logList.innerHTML = '<li>Your log is clear.</li>'; return; } [...gameState.attackLog].reverse().slice(0, 10).forEach(entry => { const li = document.createElement('li'); li.innerHTML = entry.message; li.style.color = entry.type === 'win' ? 'lime' : 'var(--primary-color)'; logList.appendChild(li); }); }

function updateRaidCooldownDisplay() { const timerEl = document.getElementById('raid-cooldown-timer'); if (!timerEl) return; const now = Date.now(); if (now < gameState.raidCooldownEnd) { const timeLeft = Math.ceil((gameState.raidCooldownEnd - now) / 1000); timerEl.innerText = `Raid Cooldown: ${timeLeft}s`; } else { timerEl.innerText = 'Raid Ready!'; } }

function duelClickCore() { if (!duelState.active) return; const damage = gameState.stats.spc * duelState.playerDamageMultiplier; duelState.opponentCurrentHealth -= damage; if (duelState.opponentCurrentHealth <= 0) endDuel(true); updateDuelUI(); }

function duelClickWeakPoint(event) { if (!duelState.active) return; const damage = (gameState.stats.spc * 5) * duelState.playerDamageMultiplier; duelState.opponentCurrentHealth -= damage; event.target.remove(); if (duelState.opponentCurrentHealth <= 0) endDuel(true); updateDuelUI(); }

function spawnWeakPoint() { if (!duelState.active) return; const arena = document.getElementById('duel-arena'); const weakPoint = document.createElement('div'); weakPoint.className = 'weak-point'; weakPoint.onclick = duelClickWeakPoint; const angle = Math.random() * 2 * Math.PI; const radius = 90; const x = Math.cos(angle) * radius + (arena.clientWidth / 2) - 20; const y = Math.sin(angle) * radius + (arena.clientHeight / 2) - 20; weakPoint.style.left = `${x}px`; weakPoint.style.top = `${y}px`; arena.appendChild(weakPoint); setTimeout(() => weakPoint.remove(), 1400); }

function duelGameLoop() { if (!duelState.active) return; const now = Date.now(); const isPlayerImmune = duelState.playerDamageImmuneUntil && now < duelState.playerDamageImmuneUntil; if (!isPlayerImmune) duelState.playerCurrentHealth -= duelState.opponentDamagePerSecond / 10; duelState.timer -= 0.1; if (duelState.playerCurrentHealth <= 0) { endDuel(false); } else if (duelState.timer <= 0) { const playerDmgPercent = 1 - (duelState.opponentCurrentHealth / duelState.opponentMaxHealth); const opponentDmgPercent = 1 - (duelState.playerCurrentHealth / duelState.playerMaxHealth); endDuel(playerDmgPercent > opponentDmgPercent); } updateDuelUI(); }

function updateDuelUI() { const opponentHealthPercent = Math.max(0, (duelState.opponentCurrentHealth / duelState.opponentMaxHealth) * 100); document.getElementById('opponent-health-fill').style.width = `${opponentHealthPercent}%`; const playerHealthPercent = Math.max(0, (duelState.playerCurrentHealth / duelState.playerMaxHealth) * 100); document.getElementById('player-health-fill').style.width = `${playerHealthPercent}%`; document.getElementById('duel-timer').innerText = Math.ceil(duelState.timer); }

function endDuel(playerWon) { clearInterval(duelState.gameInterval); clearInterval(duelState.weakPointInterval); duelState.active = false; const defender = duelState.opponent; if (playerWon) { const soulsStolen = Math.floor((defender.lifetimeSouls || 0) * 0.05); gameState.souls += soulsStolen; gameState.pvpWins++; defender.pvpLosses = (defender.pvpLosses || 0) + 1; alert(`VICTORY! You have overwhelmed ${defender.name} and stolen ${formatNumber(soulsStolen)} souls!`); gameState.attackLog.push({ type: 'win', message: `You crushed ${defender.name} and claimed ${formatNumber(soulsStolen)} souls.` }); } else { const soulsLost = Math.floor(gameState.souls * 0.05); gameState.souls -= soulsLost; gameState.pvpLosses++; defender.pvpWins = (defender.pvpWins || 0) + 1; alert(`DEFEAT! Your channeling was disrupted. You lost ${formatNumber(soulsLost)} souls.`); gameState.attackLog.push({ type: 'loss', message: `You were defeated by ${defender.name} and lost ${formatNumber(soulsLost)} souls.` }); } document.getElementById('duel-overlay').style.display = 'none'; document.getElementById('duel-arena').innerHTML = '<div id="soul-core" onclick="duelClickCore()"></div>'; gameState.raidCooldownEnd = Date.now() + 60000; renderAll(); saveGame(); }
// =================================================================
// START OF NEW PVP CODE TO COPY
// =================================================================

async function fetchPvpTargets() {
    const targetList = document.getElementById('pvp-target-list');
    if (!targetList || JSONBIN_API_KEY === "$2a$10$0DH44rvBhaAsuxkGUfBhOuJ2CKDPgeEwYWe4dOYIY7fLXh/UxQ/da" || JSONBIN_API_KEY === "PASTE_YOUR_JSONBIN.IO_API_KEY_HERE") {
        targetList.innerHTML = `<li>PvP Database not configured. <br><small>Go to jsonbin.io, get a free API key, and paste it into the script.</small></li>`;
        return;
    }

    targetList.innerHTML = '<li><em>Scouring the abyss for rivals...</em></li>';
    try {
        const res = await fetch(`https://api.jsonbin.io/v3/c/${JSONBIN_COLLECTION_ID}/bins`, { headers: { 'X-Master-Key': JSONBIN_API_KEY } });
        if (!res.ok) {
            // Give a more specific error if the server returned a bad status
            const errorBody = await res.json();
            throw new Error(`Server responded with status ${res.status}: ${errorBody.message}`);
        }
        const data = await res.json();
        
        // This is where we will store the full player data for the raidPlayer function to use
        window.potentialTargetsData = data.map(bin => bin.snippetMeta);

        const potentialTargets = window.potentialTargetsData.filter(p => 
            p.name !== gameState.playerName &&
            p.lifetimeSouls > gameState.lifetimeSouls * 0.5 &&
            p.lifetimeSouls < gameState.lifetimeSouls * 2
        ).sort(() => 0.5 - Math.random()).slice(0, 5);

        targetList.innerHTML = '';
        if (potentialTargets.length === 0) {
            targetList.innerHTML = `<li>No suitable targets found in your soul range. Keep harvesting!</li>`;
            return;
        }

        potentialTargets.forEach(player => {
            const li = document.createElement('li');
            li.innerHTML = `<span>${player.name} (Wins: ${player.pvpWins || 0})</span> <button class="upgrade-btn" style="width: 100px;" onclick="raidPlayer('${player.name}')">Raid</button>`;
            targetList.appendChild(li);
        });
    } catch(e) {
        targetList.innerHTML = `<li>Error finding targets. <br><small>Check the developer console (F12) for more details.</small></li>`;
        console.error("Detailed PvP Error:", e); // This will show the actual error in the console
    }
}

function raidPlayer(targetName) {
    if (Date.now() < gameState.raidCooldownEnd) {
        alert("Your raiding parties are exhausted. Wait for the cooldown.");
        return;
    }
    
    // **THE BUG FIX IS HERE:** We now use the 'window.potentialTargetsData' we saved earlier
    // instead of the non-existent 'mockLeaderboard'.
    if (!window.potentialTargetsData) {
        alert("Target data not found! Please find new opponents first.");
        return;
    }
    const defender = window.potentialTargetsData.find(p => p.name === targetName);

    if (!defender) {
        alert("Target has vanished!");
        return;
    }
    duelState = {
        active: true,
        timer: 15,
        opponent: defender,
        opponentMaxHealth: (defender.lifetimeSouls || 1e9) / 1e5,
        opponentCurrentHealth: (defender.lifetimeSouls || 1e9) / 1e5,
        playerMaxHealth: (gameState.lifetimeSouls || 1e6) / 1e5,
        playerCurrentHealth: (gameState.lifetimeSouls || 1e6) / 1e5,
        opponentDamagePerSecond: (defender.lifetimeSouls || 1e9) / 1e8,
        playerDamageMultiplier: 1,
    };
    const helmId = gameState.equipped.helm;
    if (helmId && items[helmId]) {
        const bonus = items[helmId].bonus;
        if (bonus.type === 'pvp_defense') duelState.opponentDamagePerSecond *= bonus.value;
        if (bonus.type === 'pvp_offense') duelState.playerDamageMultiplier = bonus.value;
        if (bonus.type === 'pvp_headstart') duelState.playerDamageImmuneUntil = Date.now() + (bonus.value * 1000);
    }
    document.getElementById('duel-overlay').style.display = 'flex';
    document.getElementById('opponent-name').innerText = `VS ${defender.name}`;
    updateDuelUI();
    duelState.gameInterval = setInterval(duelGameLoop, 100);
    duelState.weakPointInterval = setInterval(spawnWeakPoint, 1500);
}

// =================================================================
// END OF NEW PVP CODE
// =================================================================
function renderPvpLog() { const logList = document.getElementById('pvp-log-list'); if(!logList) return; logList.innerHTML = ''; if (!gameState.attackLog || gameState.attackLog.length === 0) { logList.innerHTML = '<li>Your log is clear.</li>'; return; } [...gameState.attackLog].reverse().slice(0, 10).forEach(entry => { const li = document.createElement('li'); li.innerHTML = entry.message; li.style.color = entry.type === 'win' ? 'lime' : 'var(--primary-color)'; logList.appendChild(li); }); }

function updateRaidCooldownDisplay() {
    const timerEl = document.getElementById('raid-cooldown-timer');
    if (!timerEl) {
        return;
    }

    const now = Date.now();
    if (now < gameState.raidCooldownEnd) {
        const timeLeft = Math.ceil((gameState.raidCooldownEnd - now) / 1000);
        timerEl.innerText = `Raid Cooldown: ${timeLeft}s`;
    } else {
        timerEl.innerText = 'Raid Ready!';
    }
}

function duelClickCore() {
    if (!duelState.active) {
        return;
    }
    const damage = gameState.stats.spc * duelState.playerDamageMultiplier;
    duelState.opponentCurrentHealth -= damage;
    if (duelState.opponentCurrentHealth <= 0) {
        endDuel(true);
    }
    updateDuelUI();
}

function duelClickWeakPoint(event) {
    if (!duelState.active) {
        return;
    }
    const damage = (gameState.stats.spc * 5) * duelState.playerDamageMultiplier;
    duelState.opponentCurrentHealth -= damage;
    event.target.remove();
    if (duelState.opponentCurrentHealth <= 0) {
        endDuel(true);
    }
    updateDuelUI();
}

function spawnWeakPoint() {
    if (!duelState.active) {
        return;
    }
    const arena = document.getElementById('duel-arena');
    const weakPoint = document.createElement('div');
    weakPoint.className = 'weak-point';
    weakPoint.onclick = duelClickWeakPoint;

    const angle = Math.random() * 2 * Math.PI;
    const radius = 90;
    const x = Math.cos(angle) * radius + (arena.clientWidth / 2) - 20;
    const y = Math.sin(angle) * radius + (arena.clientHeight / 2) - 20;

    weakPoint.style.left = `${x}px`;
    weakPoint.style.top = `${y}px`;

    arena.appendChild(weakPoint);
    setTimeout(() => weakPoint.remove(), 1400);
}

function duelGameLoop() {
    if (!duelState.active) {
        return;
    }
    const now = Date.now();
    const isPlayerImmune = duelState.playerDamageImmuneUntil && now < duelState.playerDamageImmuneUntil;

    if (!isPlayerImmune) {
        duelState.playerCurrentHealth -= duelState.opponentDamagePerSecond / 10;
    }

    duelState.timer -= 0.1;

    if (duelState.playerCurrentHealth <= 0) {
        endDuel(false);
    } else if (duelState.timer <= 0) {
        const playerDmgPercent = 1 - (duelState.opponentCurrentHealth / duelState.opponentMaxHealth);
        const opponentDmgPercent = 1 - (duelState.playerCurrentHealth / duelState.playerMaxHealth);
        endDuel(playerDmgPercent > opponentDmgPercent);
    }
    updateDuelUI();
}

function updateDuelUI() {
    const opponentHealthPercent = Math.max(0, (duelState.opponentCurrentHealth / duelState.opponentMaxHealth) * 100);
    document.getElementById('opponent-health-fill').style.width = `${opponentHealthPercent}%`;

    const playerHealthPercent = Math.max(0, (duelState.playerCurrentHealth / duelState.playerMaxHealth) * 100);
    document.getElementById('player-health-fill').style.width = `${playerHealthPercent}%`;

    document.getElementById('duel-timer').innerText = Math.ceil(duelState.timer);
}

function endDuel(playerWon) {
    clearInterval(duelState.gameInterval);
    clearInterval(duelState.weakPointInterval);
    duelState.active = false;
    const defender = duelState.opponent;

    if (playerWon) {
        const soulsStolen = Math.floor((defender.lifetimeSouls || 0) * 0.05);
        gameState.souls += soulsStolen;
        gameState.pvpWins++;
        defender.pvpLosses = (defender.pvpLosses || 0) + 1;
        alert(`VICTORY! You have overwhelmed ${defender.name} and stolen ${formatNumber(soulsStolen)} souls!`);
        gameState.attackLog.push({
            type: 'win',
            message: `You crushed ${defender.name} and claimed ${formatNumber(soulsStolen)} souls.`
        });
    } else {
        const soulsLost = Math.floor(gameState.souls * 0.05);
        gameState.souls -= soulsLost;
        gameState.pvpLosses++;
        defender.pvpWins = (defender.pvpWins || 0) + 1;
        alert(`DEFEAT! Your channeling was disrupted. You lost ${formatNumber(soulsLost)} souls.`);
        gameState.attackLog.push({
            type: 'loss',
            message: `You were defeated by ${defender.name} and lost ${formatNumber(soulsLost)} souls.`
        });
    }

    document.getElementById('duel-overlay').style.display = 'none';
    document.getElementById('duel-arena').innerHTML = '<div id="soul-core" onclick="duelClickCore()"></div>';
    gameState.raidCooldownEnd = Date.now() + 60000;
    
    renderAll();
    saveGame();
}
// =================================================================
// ANTI-CHEAT & VISUALS
// =================================================================
function runAntiCheatChecks() {
    const now = Date.now();
    checkClickSpam(now);
    checkClickRhythm(now);
}

function checkClickSpam(now) {
    antiCheatState.clickTimestamps.push(now);
    const oneSecondAgo = now - 1000;
    antiCheatState.clickTimestamps = antiCheatState.clickTimestamps.filter(t => t >= oneSecondAgo);

    if (antiCheatState.clickTimestamps.length > 25) {
        console.warn("Anti-Cheat Triggered: High CPS");
        punishPlayer();
    }
}

function checkClickRhythm(now) {
    if (antiCheatState.clickTimestamps.length < 2) {
        return;
    }
    const lastClickTime = antiCheatState.clickTimestamps[antiCheatState.clickTimestamps.length - 2];
    const interval = now - lastClickTime;
    antiCheatState.clickIntervals.push(interval);

    if (antiCheatState.clickIntervals.length > 10) {
        antiCheatState.clickIntervals.shift();
        const stdDev = calculateStandardDeviation(antiCheatState.clickIntervals);
        if (stdDev < 3) {
            console.warn(`Anti-Cheat Triggered: Low Rhythm Deviation (${stdDev})`);
            punishPlayer();
        }
    }
}

function punishPlayer() {
    if (antiCheatState.isLockedOut) {
        return;
    }
    antiCheatState.isLockedOut = true;
    antiCheatState.punishmentLevel++;
    const lockoutTime = 5000 * antiCheatState.punishmentLevel;
    
    alert(`An unstable connection to the abyss has been detected. Harvesting disabled for ${lockoutTime / 1000} seconds.`);

    const btn = document.querySelector('.action-btn');
    const originalText = btn.innerText;
    btn.innerText = "CONNECTION UNSTABLE";
    btn.disabled = true;

    setTimeout(() => {
        antiCheatState.isLockedOut = false;
        btn.innerText = originalText;
        btn.disabled = false;
        antiCheatState.clickTimestamps = [];
        antiCheatState.clickIntervals = [];
    }, lockoutTime);
}

function calculateStandardDeviation(array) {
    if (!array.length) {
        return 0;
    }
    const n = array.length;
    const mean = array.reduce((a, b) => a + b) / n;
    const variance = array.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / n;
    return Math.sqrt(variance);
}
// Abyssal Rift Canvas
let riftCtx, riftParticles; function initRift() { const canvas = document.getElementById('rift-canvas'); if (!canvas) return; riftCtx = canvas.getContext('2d'); const btn = document.querySelector('.action-btn'); canvas.width = btn.offsetWidth + 100; canvas.height = btn.offsetHeight + 100; riftParticles = []; for (let i = 0; i < 50; i++) riftParticles.push({ x: canvas.width / 2, y: canvas.height / 2, size: Math.random() * 2 + 1, speedX: (Math.random() - 0.5) * 2, speedY: (Math.random() - 0.5) * 2, color: `rgba(179, 33, 33, ${Math.random() * 0.5 + 0.2})`, life: 0, maxLife: Math.random() * 100 + 50, }); function drawRift() { riftCtx.clearRect(0, 0, canvas.width, canvas.height); riftParticles.forEach(p => { p.x += p.speedX; p.y += p.speedY; p.life++; if (p.life >= p.maxLife) { p.x = canvas.width / 2; p.y = canvas.height / 2; p.life = 0; p.speedX = (Math.random() - 0.5) * (1 + gameState.stats.spc / 1000); p.speedY = (Math.random() - 0.5) * (1 + gameState.stats.spc / 1000); } const intensity = Math.sin(p.life / p.maxLife * Math.PI); riftCtx.beginPath(); riftCtx.fillStyle = p.color; riftCtx.globalAlpha = intensity; riftCtx.arc(p.x, p.y, p.size * intensity, 0, Math.PI * 2); riftCtx.fill(); }); requestAnimationFrame(drawRift); } drawRift(); }
</script>
</body>
</html>
